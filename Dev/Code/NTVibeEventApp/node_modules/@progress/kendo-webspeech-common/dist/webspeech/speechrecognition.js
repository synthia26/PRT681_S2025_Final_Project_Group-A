"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KendoSpeechRecognition = void 0;
const START = "start";
const END = "end";
const RESULT = "result";
const ERROR = "error";
const DEFAULT_SPEECH_OPTIONS = {
    lang: 'en-US',
    continuous: false,
    interimResults: false,
    maxAlternatives: 1,
    events: {
        [START]: null,
        [END]: null,
        [RESULT]: null,
        [ERROR]: null
    }
};
function getSpeechRecognitionCtor() {
    return window ? (window.SpeechRecognition || window.webkitSpeechRecognition) : undefined;
}
class KendoSpeechRecognition {
    constructor(options) {
        this.recognition = null;
        this.isListening = false;
        this.options = { ...DEFAULT_SPEECH_OPTIONS };
        this.handleResult = (event) => {
            this.triggerOnResult(event);
        };
        this.handleError = (event) => {
            this.triggerOnError(event);
        };
        this.handleEnd = () => {
            this.triggerOnEnd();
            this.isListening = false;
        };
        this.handleStart = () => {
            this.triggerOnStart();
            this.isListening = true;
        };
        this.init(options);
    }
    init(options) {
        const RecognitionCtor = getSpeechRecognitionCtor();
        if (!RecognitionCtor) {
            console.error('Speech recognition is not supported in this browser.');
            this.recognition = null;
            return;
        }
        this.recognition = new RecognitionCtor();
        this.setOptions(options);
        this.bindEvents();
    }
    destroy() {
        this.unbindEvents();
        this.isListening = false;
    }
    bindEvents() {
        if (!this.recognition) {
            return;
        }
        this.recognition.onresult = this.handleResult;
        this.recognition.onerror = this.handleError;
        this.recognition.onend = this.handleEnd;
        this.recognition.onstart = this.handleStart;
    }
    unbindEvents() {
        if (this.recognition) {
            this.recognition.onresult = null;
            this.recognition.onerror = null;
            this.recognition.onend = null;
            this.recognition.onstart = null;
            this.recognition.abort();
            this.recognition = null;
        }
    }
    setOptions(options) {
        if (!this.recognition) {
            return;
        }
        const mergedEvents = { ...this.options.events, ...options.events };
        this.options = {
            ...this.options,
            ...options,
            events: mergedEvents
        };
        const { lang, continuous, interimResults, maxAlternatives } = this.options;
        Object.assign(this.recognition, { lang, continuous, interimResults, maxAlternatives });
    }
    triggerOnStart() {
        if (this.options.events[START]) {
            this.options.events[START]();
        }
    }
    triggerOnEnd() {
        if (this.options.events[END]) {
            this.options.events[END]();
        }
    }
    triggerOnResult(event) {
        if (this.options.events[RESULT]) {
            this.options.events[RESULT](event);
        }
    }
    triggerOnError(event) {
        if (this.options.events[ERROR]) {
            this.options.events[ERROR](event);
        }
    }
    start() {
        if (this.recognition && !this.isListening) {
            this.recognition.start();
        }
    }
    stop() {
        if (this.recognition && this.isListening) {
            this.recognition.stop();
        }
    }
    abort() {
        if (this.recognition && this.isListening) {
            this.recognition.abort();
        }
    }
    isSupported() {
        return !!getSpeechRecognitionCtor();
    }
    isActive() {
        return this.isListening;
    }
}
exports.KendoSpeechRecognition = KendoSpeechRecognition;
