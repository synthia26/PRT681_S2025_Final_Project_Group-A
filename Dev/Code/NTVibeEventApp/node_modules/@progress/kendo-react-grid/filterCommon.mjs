/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { messages as g } from "./messages/index.mjs";
import { IntlService as u } from "@progress/kendo-react-intl";
const q = [
  { text: "grid.filterAndLogic", operator: "and" },
  { text: "grid.filterOrLogic", operator: "or" }
], E = {
  text: [
    { text: "grid.filterContainsOperator", operator: "contains" },
    { text: "grid.filterNotContainsOperator", operator: "doesnotcontain" },
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterStartsWithOperator", operator: "startswith" },
    { text: "grid.filterEndsWithOperator", operator: "endswith" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" },
    { text: "grid.filterIsEmptyOperator", operator: "isempty" },
    { text: "grid.filterIsNotEmptyOperator", operator: "isnotempty" }
  ],
  numeric: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterGteOperator", operator: "gte" },
    { text: "grid.filterGtOperator", operator: "gt" },
    { text: "grid.filterLteOperator", operator: "lte" },
    { text: "grid.filterLtOperator", operator: "lt" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  date: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterAfterOrEqualOperator", operator: "gte" },
    { text: "grid.filterAfterOperator", operator: "gt" },
    { text: "grid.filterBeforeOperator", operator: "lt" },
    { text: "grid.filterBeforeOrEqualOperator", operator: "lte" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  boolean: [{ text: "grid.filterEqOperator", operator: "eq" }]
}, a = (t) => t === "isnull" || t === "isnotnull" || t === "isempty" || t === "isnotempty", h = (t, i) => t.map((e) => ({
  text: i.toLanguageString(e.text, g[e.text]),
  operator: e.operator
})), x = "eq", N = [
  { text: "grid.filterBooleanAll", operator: "" },
  { text: "grid.filterIsTrue", operator: !0 },
  { text: "grid.filterIsFalse", operator: !1 }
], I = {
  text: !1,
  numeric: !1,
  date: !1,
  boolean: !0
}, v = (t, i, e) => {
  const o = O(e.operators);
  let r = e.operator;
  switch (e.filterType) {
    case "numeric":
      (!r || a(r)) && (r = o), t === null && r === o && (r = "");
      break;
    case "date":
      (!r || a(r)) && (r = o), t === null && r === o && (r = "");
      break;
    case "text":
      (!r || a(r)) && (r = o), !t && r === o && (r = "");
      break;
    default:
      return;
  }
  e.onChange({ value: t, operator: r, syntheticEvent: i });
}, O = (t, i) => i ? t[i][0].operator : t[0].operator, F = (t) => t || "text", b = (t, i) => {
  const e = t.target.value;
  i({
    value: e.operator,
    operator: e.operator === "" ? "" : x,
    syntheticEvent: t.syntheticEvent
  });
}, A = (t, i, e) => {
  let o = i;
  const r = t.target.value;
  t.target.state.opened && (a(r.operator) && (o = null), i === null && !a(r.operator) && (o = void 0), e({ value: o, operator: r.operator, syntheticEvent: t.syntheticEvent }));
}, d = (t, i) => {
  const e = i || new u("en-US");
  if (t.value) {
    const o = e.parseDate(t.value);
    o && (t.value = o);
  }
  t.filters && (t.filters = t.filters.map(
    (o) => {
      if (o.value) {
        const r = e.parseDate(o.value);
        r && (o.value = r);
      }
      return o;
    }
  ));
}, C = (t, i) => {
  var o;
  let e = t;
  if (e && Object.keys(e).length === 0 && (e = null), e != null && e.filters && Array.isArray(e.filters)) {
    const r = i || { filters: [], logic: "and" }, c = r.filters.map((l) => l.field || l.filters[0].field), n = e.filters.every((l) => l.field === (e == null ? void 0 : e.filters[0]).field), s = n ? [
      {
        filters: e.filters.map((l) => (d(l), l)),
        logic: e.logic
      }
    ] : e.filters.map((l) => {
      const f = l.filters ? l : {
        logic: t.logic,
        filters: [l]
      };
      return d(f), f;
    }), p = n && c.includes(s[0].filters[0].field);
    if (p) {
      const l = r.filters[0];
      l.filters && ((o = l.filters) == null || o.push(...s[0].filters), l.logic = t.logic);
    }
    e = {
      ...r,
      filters: p ? r.filters : [...r.filters, ...s]
    };
  }
  return e;
};
export {
  a as IsUnaryFilter,
  N as booleanFilterValues,
  b as cellBoolDropdownChange,
  v as cellInputChange,
  A as cellOperatorChange,
  C as combineSmartFilters,
  x as defaultBooleanOperator,
  I as defaultHideSecondFilter,
  q as filterLogicList,
  O as getDefaultOperator,
  F as getFilterType,
  h as operatorMap,
  E as operators,
  d as parseFilterDates
};
