/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as w from "react";
import { gridDefaultProps as v } from "../GridColumn.mjs";
import { getter as y } from "@progress/kendo-data-query";
import { findGroupExpand as F, updateLeft as D, updateRight as E, tableKeyboardNavigationTools as p } from "@progress/kendo-react-data-tools";
import { ServerFragment as M } from "./_serverModule.mjs";
import { ClientFragment as b } from "./_clientModule.mjs";
import { GridContextMenuItemNames as f } from "../contextMenu/enums.mjs";
import { canUseDOM as A } from "@progress/kendo-react-common";
function J(e, t) {
  const n = (e != null ? e : "").split(".");
  let i = t;
  return n.forEach((d) => {
    i = i ? i[d] : void 0;
  }), i;
}
function R(e, t, n, i, d, o, r, a, l, c = 0, h) {
  var x;
  let g = c;
  for (let s = 0; s < t.length; s++) {
    let I;
    if (!d || t[s].value === void 0 || t[s].items === void 0) {
      e[e.length] = {
        dataIndex: i.index,
        dataItem: t[s],
        rowType: "data",
        level: c,
        group: h,
        // This is related to detail-row expansion
        expanded: (x = l ? !!(o != null && o[y(l)(t[s])]) : !1) != null ? x : !1
      }, i.index++;
      continue;
    } else {
      let S;
      h != null && h.parents ? S = [{ field: h.field, value: h.value }, ...h.parents] : h ? S = [h] : S = [], I = {
        field: t[s].field,
        value: t[s].value,
        parents: S
      };
    }
    g = Math.max(g, c + 1);
    let C = !1;
    const u = F(r || [], I);
    u ? C = u.expanded !== !1 : C = a !== !1, e[e.length] = {
      dataIndex: -1,
      dataItem: t[s],
      level: c,
      group: I,
      rowType: "groupHeader",
      expanded: C
    }, C && (I.expanded = C, g = Math.max(
      R(
        e,
        t[s].items,
        n,
        i,
        d,
        o,
        r,
        a,
        l,
        c + 1,
        I
      ),
      g
    )), (n === "always" || C && n === "visible") && (e[e.length] = {
      dataIndex: -1,
      dataItem: t[s],
      rowType: "groupFooter",
      level: c,
      expanded: C
    });
  }
  return g;
}
const K = (e, t) => typeof e.colSpan == "function" ? e.colSpan({ dataItem: t, column: e }) : e.colSpan || 1;
function Q(e, t) {
  const n = [[]];
  let i = 0;
  for (let r = e.length - 1; r >= 0; r--)
    i = Math.max(i, e[r].depth), e[r].headerColSpan = e[r].headerColSpan || 1, e[r].children.length > 0 && (e[r].headerColSpan = e[r].children.reduce(
      (a, l) => l.hidden ? a : a + l.headerColSpan,
      0
    ));
  const d = [];
  let o = 1;
  return e.forEach((r, a) => {
    n[r.depth] = n[r.depth] || [];
    let l = !1;
    n[r.depth].length === 0 && (o <= 1 ? o = 1 + (r.children.length > 0 ? 0 : i - r.depth) : (o--, l = !0)), r.rowSpan = 1 + (r.children.length > 0 ? 0 : i - r.depth), r.kFirst = l, r.index = n[r.depth].length, n[r.depth].push(a), r.ariaColumnIndex = d[r.depth] ? d[r.depth] + 1 : 1;
    for (let c = r.depth; c < r.depth + r.rowSpan; c++)
      d[c] = (d[c] || 0) + r.headerColSpan;
  }), D(n, e, t), E(n, e, t), n;
}
function m(e, t, n, i = 0, d = !1) {
  const o = [];
  if (!e)
    return [];
  e && e.length === void 0 && (e = [e]), e.forEach((a, l) => {
    a = a.props ? a.props : a;
    const c = a.id ? a.id : p.generateNavigatableId(`${n.prevId++}`, n.idPrefix, "column"), h = A && a.media && window.matchMedia ? !window.matchMedia(a.media).matches : !1, g = d || h || a.hidden, x = t == null ? void 0 : t.find((I) => I.id === c), s = m(a.children, (x == null ? void 0 : x.children) || [], n, i + 1, g);
    o.push(
      Object.assign(
        { depth: i },
        v,
        s.length ? { cell: () => null, filterCell: () => null } : {},
        a,
        {
          id: c,
          declarationIndex: o.length,
          children: s,
          headerColSpan: 0,
          rowSpan: 0,
          columnType: a.columnType || "data",
          colSpan: a.colSpan || 1,
          isAccessible: !0,
          hidden: g,
          left: null,
          right: null,
          rowSpannable: a.rowSpannable
        },
        x ? { width: x.width, orderIndex: x.orderIndex } : {}
      )
    );
  });
  const r = (a, l) => a.orderIndex === l.orderIndex ? a.declarationIndex - l.declarationIndex : (a.orderIndex || 0) - (l.orderIndex || 0);
  if (o.sort(r), i === 0) {
    const a = [], l = (c, h) => c.forEach((g) => {
      g.parentIndex = h, l(g.children, a.push(g) - 1);
    });
    return l(o, -1), a;
  }
  return o;
}
const H = (e) => Array.isArray(e) ? e : e ? e.data : [];
function X(e, t, n, i) {
  const d = H(e), o = [];
  if (d.length > 0) {
    let r = d[0];
    if (t)
      for (let l = 0; l < t.length; l++)
        r = r.items && r.items[0];
    Object.getOwnPropertyNames(r).forEach((l) => {
      l !== n.column && o.push(
        Object.assign(
          {
            id: p.generateNavigatableId(`${i.prevId++}`, i.idPrefix, "column"),
            declarationIndex: -1,
            parentIndex: -1,
            depth: 0,
            colSpan: 0,
            headerColSpan: 0,
            rowSpan: 0,
            index: 0,
            columnType: "data",
            left: 0,
            right: 0,
            rightBorder: !1,
            children: [],
            ariaColumnIndex: 0,
            isAccessible: !0
          },
          v,
          { field: l }
        )
      );
    });
  }
  return o;
}
const T = (e, t) => {
  var i;
  let n = e[t.parentIndex];
  for (; n; ) {
    if ((i = n.cells) != null && i.footerCell)
      return !0;
    n = e[n.parentIndex];
  }
  return !1;
}, Y = (e) => e.filter((t) => {
  var n;
  return T(e, t) ? !1 : !!((n = t.cells) != null && n.footerCell) || !(t.children && t.children.length > 0);
}), Z = (e) => e.width !== void 0 ? Math.floor(parseFloat(e.width.toString())) + "px" : void 0, _ = (e, t) => t && t.filter((n) => n.field === e).length > 0, j = (e) => (e.sort((t, n) => t.declarationIndex - n.declarationIndex), e.map((t) => {
  const { declarationIndex: n, parentIndex: i, depth: d, headerColSpan: o, rowSpan: r, index: a, kFirst: l, children: c, ...h } = t;
  return c.length ? {
    children: j(c),
    ...h
  } : h;
})), B = (e) => {
  const { cells: t, rowSpannable: n, defaultCell: i, ...d } = e;
  return e.children.length ? {
    ...d,
    children: e.children.map(B)
  } : d;
}, O = (e) => ({
  id: e.id,
  field: e.field,
  title: e.title,
  width: e.width,
  hidden: !1,
  children: e.children ? N(e.children) : null
}), N = (e) => e.map(O), P = (e) => {
  const t = [], n = (i) => i == null ? void 0 : i.forEach((d) => {
    t.push(d), n(d.children);
  });
  return n(e), t;
}, G = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), ee = 17895697, te = (e) => {
  let t = [];
  return e.sortable && (t = t.concat([f.sortAsc, f.sortDesc])), e.pdf && (t.length && (t = t.concat([f.separator])), t = t.concat([f.exportPDF])), t;
}, ne = (e) => {
  let t = [];
  return e.clipboard && (t = t.concat([
    f.copySelection,
    f.copySelectionNoHeaders,
    f.paste
  ])), e.editable && (t.length && (t = t.concat([f.separator])), t = t.concat([
    f.create,
    f.edit,
    f.delete
  ])), e.selectable && (t.length && (t = t.concat([f.separator])), t = t.concat([f.select])), e.rowReorderable && (t.length && (t = t.concat([f.separator])), t = t.concat([f.reorderRow])), e.pdf && (t.length && (t = t.concat([f.separator])), t = t.concat([f.exportPDF])), t;
}, re = (e, t) => {
  if (!(!e && !t))
    return t ? e ? {
      ...e,
      ...t,
      select: {
        ...e.select || {},
        ...t.select || {}
      },
      hierarchy: {
        ...e.hierarchy || {},
        ...t.hierarchy || {}
      },
      group: {
        ...e.group || {},
        ...t.group || {}
      },
      edit: {
        ...e.edit || {},
        ...t.edit || {}
      }
    } : t : e;
}, ie = (e) => {
  var n;
  return typeof e == "object" ? (n = e.enabled) != null ? n : !0 : e != null ? e : !1;
}, ae = () => M === b, de = (e) => !!(e && e.$$typeof === Symbol.for("react.client.reference")), le = (e) => ({
  id: e.id,
  ariaColumnIndex: e.ariaColumnIndex,
  isSelected: e.isSelected,
  isHighlighted: e.isHighlighted,
  isInEdit: e.isInEdit,
  isSorted: e.isSorted,
  isAlt: e.isAlt,
  expanded: e.expanded,
  className: e.className,
  style: e.style,
  field: e.field,
  dataItem: e.dataItem,
  format: e.format,
  colSpan: e.colSpan,
  dataIndex: e.dataIndex,
  columnIndex: e.columnIndex,
  columnsCount: e.columnsCount,
  rowType: e.rowType,
  level: e.level,
  editor: e.editor,
  locked: e.locked,
  isRtl: e.isRtl,
  rowDataIndex: e.rowDataIndex,
  columnPosition: e.columnPosition,
  group: e.group
}), oe = (e) => {
  var i, d;
  const t = typeof e == "object" ? (i = e.enabled) != null ? i : !0 : e != null ? e : !1, n = typeof e == "object" ? (d = e.valueGetter) != null ? d : (o, r) => y(r)(o) : (o, r) => y(r)(o);
  return { enabled: t, valueGetter: n };
}, k = (e) => {
  var t;
  return w.isValidElement(e) ? e : (t = w.Children.toArray(e)) == null ? void 0 : t[0];
}, ce = (e, t) => {
  const n = k(e);
  return n ? w.cloneElement(n, t) : null;
}, fe = (e) => {
  let t = 0;
  if (e) {
    const n = e.insertRow(0), i = n.insertCell(0);
    i.textContent = "&nbsp;", t = n.getBoundingClientRect().height, e.deleteRow(0);
  }
  return t;
};
export {
  X as autoGenerateColumns,
  fe as calcRowHeight,
  B as clientColumn,
  ce as cloneReactElement,
  G as firefox,
  ee as firefoxMaxHeight,
  R as flatData,
  Y as footerColumns,
  le as getClientCellProps,
  K as getColSpan,
  O as getColumnState,
  Z as getColumnWidth,
  N as getColumnsState,
  H as getDataAsArray,
  ne as getDefaultBodyContextMenuItems,
  te as getDefaultHeadContextMenuItems,
  P as getFlatColumnsState,
  J as getNestedValue,
  k as getReactElement,
  oe as getRowSpanOptions,
  ae as isClient,
  de as isClientReference,
  ie as isRowReorderEnabled,
  _ as isSorted,
  Q as mapColumns,
  m as readColumns,
  re as resolveCells,
  j as sanitizeColumns
};
