/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const D=require("react"),i=require("@progress/kendo-react-common"),y=require("./package-metadata.js");function E(s){const a=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(s){for(const o in s)if(o!=="default"){const r=Object.getOwnPropertyDescriptor(s,o);Object.defineProperty(a,o,r.get?r:{enumerable:!0,get:()=>s[o]})}}return a.default=s,Object.freeze(a)}const l=E(D),S=s=>{const{data:a=[]}=s,o=!i.validatePackage(y.packageMetadata,{component:"StatusBar"}),r=i.getLicenseMessage(y.packageMetadata);return l.createElement("div",{className:"k-selection-aggregates k-grid-selection-aggregates"},a.map((g,m)=>l.createElement("div",{key:m},l.createElement("span",{className:"k-selection-aggregates-item-text"},g.type,": "),l.createElement("span",{className:"k-selection-aggregates-item-value"},g.formattedValue))),o&&l.createElement(i.WatermarkOverlay,{message:r}))};S.displayName="KendoReactGridStatusBar";const k=s=>{var o;const a=s.slice();for(let r=0;r<a.length;r++)for(;a[r]&&((o=a[r].children)!=null&&o.length);)a.splice(r,1,...a[r].children);return a},O=s=>{const{dataItems:a,target:o}=s,g=k(o.columns).map(e=>e.field).filter(e=>e&&typeof e=="string").map(e=>i.getter(e)),m=e=>s.select[i.getter(s.dataItemKey)(e)],t={dates:[],numbers:[],booleans:[],others:[]},M=e=>{typeof e=="number"?t.numbers.push(e):typeof e=="boolean"?t.booleans.push(e):e instanceof Date?t.dates.push(e):t.others.push(e)};a.forEach(e=>{const n=m(e);Array.isArray(n)&&n.forEach(c=>{M(g[c](e))})});const d=t.dates.map(e=>e.getTime()),f=t.booleans.filter(e=>e).length,h=t.booleans.filter(e=>!e).length,u=t.numbers.length?t.numbers.reduce((e,n)=>e+n,0):void 0,p={sum:u,average:typeof u=="number"?u/t.numbers.length:void 0,min:t.numbers.length?Math.min(...t.numbers):void 0,max:t.numbers.length?Math.max(...t.numbers):void 0,count:t.numbers.length+t.booleans.length+t.dates.length+t.others.length,isTrue:f>0?f:void 0,isFalse:h>0?h:void 0,earliest:t.dates.length?new Date(Math.min(...d)):void 0,latest:t.dates.length?new Date(Math.max(...d)):void 0},v=(e,n)=>(n==="sum"||n==="average")&&typeof e=="number"?e.toFixed(2):(n==="earliest"||n==="latest")&&e instanceof Date?e.toLocaleDateString():String(e),b=[];return Object.keys(p).forEach(e=>{const n=e,c=p[n];c!==void 0&&b.push({type:n,value:c,formattedValue:v(c,n)})}),b};exports.StatusBar=S;exports.getStatusData=O;exports.leafColumns=k;
