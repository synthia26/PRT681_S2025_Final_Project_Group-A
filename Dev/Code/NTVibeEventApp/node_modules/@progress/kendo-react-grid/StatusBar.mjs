/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as l from "react";
import { validatePackage as v, getLicenseMessage as M, WatermarkOverlay as S, getter as b } from "@progress/kendo-react-common";
import { packageMetadata as y } from "./package-metadata.mjs";
const x = (o) => {
  const { data: a = [] } = o, r = !v(y, { component: "StatusBar" }), n = M(y);
  return /* @__PURE__ */ l.createElement("div", { className: "k-selection-aggregates k-grid-selection-aggregates" }, a.map((i, m) => /* @__PURE__ */ l.createElement("div", { key: m }, /* @__PURE__ */ l.createElement("span", { className: "k-selection-aggregates-item-text" }, i.type, ": "), /* @__PURE__ */ l.createElement("span", { className: "k-selection-aggregates-item-value" }, i.formattedValue))), r && /* @__PURE__ */ l.createElement(S, { message: n }));
};
x.displayName = "KendoReactGridStatusBar";
const D = (o) => {
  var r;
  const a = o.slice();
  for (let n = 0; n < a.length; n++)
    for (; a[n] && ((r = a[n].children) != null && r.length); )
      a.splice(n, 1, ...a[n].children);
  return a;
}, A = (o) => {
  const { dataItems: a, target: r } = o, i = D(r.columns).map((e) => e.field).filter((e) => e && typeof e == "string").map(
    (e) => b(e)
  ), m = (e) => o.select[b(o.dataItemKey)(e)], t = { dates: [], numbers: [], booleans: [], others: [] }, E = (e) => {
    typeof e == "number" ? t.numbers.push(e) : typeof e == "boolean" ? t.booleans.push(e) : e instanceof Date ? t.dates.push(e) : t.others.push(e);
  };
  a.forEach((e) => {
    const s = m(e);
    Array.isArray(s) && s.forEach((c) => {
      E(i[c](e));
    });
  });
  const d = t.dates.map((e) => e.getTime()), u = t.booleans.filter((e) => e).length, h = t.booleans.filter((e) => !e).length, g = t.numbers.length ? t.numbers.reduce((e, s) => e + s, 0) : void 0, f = {
    sum: g,
    average: typeof g == "number" ? g / t.numbers.length : void 0,
    min: t.numbers.length ? Math.min(...t.numbers) : void 0,
    max: t.numbers.length ? Math.max(...t.numbers) : void 0,
    count: t.numbers.length + t.booleans.length + t.dates.length + t.others.length,
    isTrue: u > 0 ? u : void 0,
    isFalse: h > 0 ? h : void 0,
    earliest: t.dates.length ? new Date(Math.min(...d)) : void 0,
    latest: t.dates.length ? new Date(Math.max(...d)) : void 0
  }, k = (e, s) => (s === "sum" || s === "average") && typeof e == "number" ? e.toFixed(2) : (s === "earliest" || s === "latest") && e instanceof Date ? e.toLocaleDateString() : String(e), p = [];
  return Object.keys(f).forEach((e) => {
    const s = e, c = f[s];
    c !== void 0 && p.push({ type: s, value: c, formattedValue: k(c, s) });
  }), p;
};
export {
  x as StatusBar,
  A as getStatusData,
  D as leafColumns
};
