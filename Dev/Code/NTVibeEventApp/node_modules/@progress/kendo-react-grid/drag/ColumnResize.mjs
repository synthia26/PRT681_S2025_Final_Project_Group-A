/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { getFlatColumnsState as u } from "../utils/index.mjs";
const m = 1, w = 20;
class E {
  constructor(p) {
    this.columns = [], this.columnsState = [], this.resizable = !1, this.isRtl = !1, this.setIsRtl = (c) => {
      this.isRtl = c;
    }, this.initWidths = () => {
      var n;
      const c = ((n = this.colGroupMain) == null ? void 0 : n.children) || [], r = u(this.columnsState), l = this.columns.filter((h) => {
        var o;
        return !((o = h.children) != null && o.length);
      });
      for (let h = 0; h < c.length; h++) {
        const o = c[h];
        let t = "";
        const i = r.find((s) => s.id === l[h].id);
        i && (t = i.width || ""), o.width = t, this.colGroupHeader && (this.colGroupHeader.children[h].width = t), this.colGroupFooter && (this.colGroupFooter.children[h].width = t);
      }
    }, this.dragHandler = (c, r, l, n) => {
      const h = c.originalEvent;
      n || (h.preventDefault(), h.stopPropagation(), h.stopImmediatePropagation());
      const o = l.closest("th");
      if (!o || !o)
        return;
      const t = o.clientWidth;
      let i = t;
      if (this.isRtl ? i += l.getBoundingClientRect().right - l.offsetWidth / 2 - c.clientX : i += c.clientX - l.getBoundingClientRect().left - l.offsetWidth / 2, !n && Math.abs(i - t) < 1)
        return;
      this.fixateInitialWidths(o.parentElement.clientWidth), this.setWidths(r, Math.floor(i) / t);
      const s = this.columns.filter((e) => !e.children.length).findIndex((e) => e.id === r.id);
      this.onResize(s, t, i, h, n, this.columnsState, r.id);
    }, this.dblClickHandler = (c, r) => {
      const l = this.columns.filter((d) => r.indexOf(d.id) > -1), n = u(this.columnsState);
      if (!this.colGroupMain || !l.length)
        return;
      const h = {}, o = l;
      for (; o.length > 0; ) {
        const d = o.pop();
        if (!d)
          break;
        d.children.length ? o.push(...d.children) : h[d.id] = d;
      }
      const t = this.columns.filter((d) => !d.children.length), i = [];
      t.forEach((d, f) => {
        h[d.id] && i.push(f);
      });
      const s = [this.colGroupMain.parentElement], e = [this.colGroupMain];
      this.colGroupHeader && (s.push(this.colGroupHeader.parentElement), e.push(this.colGroupHeader)), this.colGroupFooter && (s.push(this.colGroupFooter.parentElement), e.push(this.colGroupFooter)), s.forEach((d) => d.classList.add("k-autofitting"));
      const a = [];
      e.forEach((d) => {
        i.forEach((f) => {
          d.children[f] && (d.children[f].width = "", a[f] = Math.max(
            a[f] || 0,
            d.children[f].offsetWidth + m
          ));
        });
      }), e.forEach((d) => {
        i.forEach((f) => {
          if (d.children[f]) {
            d.children[f].width = a[f] + "px";
            const g = n.find((G) => G.id === t[f].id);
            g && (g.width = a[f]);
          }
        });
      }), s.forEach((d) => d.classList.remove("k-autofitting")), this.onResize(i[0], 0, 0, c, !0, this.columnsState, r[0]);
    }, this.updateColElements = (c) => {
      const r = this.columns.filter((n) => !n.hidden && !n.children.length);
      let l = 1e-10;
      for (let n = 0; n < c.length; n++) {
        const h = c[n], o = r.findIndex((a) => a.id === h.id), t = parseFloat((h.width || 0).toString()), i = Math.floor(t);
        l += t - i;
        const s = i + Math.floor(l);
        l -= Math.floor(l);
        const e = r.find((a) => a.id === h.id);
        if (!e)
          return;
        if (this.colGroupMain && this.colGroupMain.children[o]) {
          const a = parseInt(this.colGroupMain.children[o].width, 10);
          this.colGroupMain.children[o].width = s + "px", this.updateNextLockedCol(this.colGroupMain.parentElement, e, a - s);
        }
        if (this.colGroupHeader && this.colGroupHeader.children[o]) {
          const a = parseInt(this.colGroupHeader.children[o].width, 10);
          this.colGroupHeader.children[o].width = s + "px", this.updateNextLockedCol(this.colGroupHeader.parentElement, e, a - s);
        }
        if (this.colGroupFooter && this.colGroupFooter.children[o]) {
          const a = parseInt(this.colGroupFooter.children[o].width, 10);
          this.colGroupFooter.children[o].width = s + "px", this.updateNextLockedCol(this.colGroupFooter.parentElement, e, a - s);
        }
      }
    }, this.onResize = p;
  }
  fixateInitialWidths(p) {
    var o;
    let c = 0;
    const r = ((o = this.colGroupMain) == null ? void 0 : o.children) || [];
    for (let t = 0; t < r.length; t++)
      r[t].width ? p -= r[t].clientWidth : c++;
    if (c === 0)
      return;
    const l = Math.floor(p / c), n = u(this.columnsState), h = this.columns.filter((t) => !t.children.length);
    for (let t = 0; t < r.length; t++) {
      const i = r[t], s = i.width ? i.clientWidth : l;
      i.width = s;
      const e = n.find((a) => a.id === h[t].id);
      e && (e.width = s.toString()), this.colGroupHeader && (this.colGroupHeader.children[t].width = s), this.colGroupFooter && (this.colGroupFooter.children[t].width = s);
    }
  }
  setWidths(p, c) {
    const r = u(this.columnsState), l = this.columns.findIndex((t) => t.id === p.id), n = [];
    let h = p.children.filter((t) => !t.hidden).length;
    for (let t = l + 1; t < this.columns.length && !(h <= 0); t++) {
      const i = this.columns[t];
      i.children.length ? h += i.children.filter((s) => !s.hidden).length : n.push(i), h--;
    }
    n.length === 0 && n.push(p);
    const o = [];
    n.forEach((t) => {
      const i = r.find((s) => s.id === t.id);
      if (i) {
        let s = i.width ? parseFloat(i.width.toString()) * c : 0;
        const e = t.minResizableWidth === void 0 ? 10 : t.minResizableWidth;
        s < e && (s = e), i.width = s, o.push(i);
      }
    }), this.updateColElements(o);
  }
  updateNextLockedCol(p, c, r) {
    const l = c.index, n = this.colGroupMain.parentElement.closest(".k-grid"), h = n == null ? void 0 : n.clientWidth, o = this.columns.filter((t) => t.locked).map((t) => parseInt(t.width + "", 10)).reduce((t, i) => t + i, 0);
    !c.locked || h <= o + w || this.columns.forEach((t) => {
      if (t != null && t.locked && r) {
        const i = p == null ? void 0 : p.querySelectorAll('[aria-colindex="' + t.ariaColumnIndex + '"]');
        i == null || i.forEach((s) => {
          const e = s.style;
          this.isRtl ? (t.index > l && e && e.right && (e.right = parseInt(e.right, 10) - r + "px"), t.index < l && e && e.left && (e.left = parseInt(e.left, 10) - r + "px")) : (t.index > l && e && e.left && (e.left = parseInt(e.left, 10) - r + "px"), t.index < l && e && e.right && (e.right = parseInt(e.right, 10) - r + "px"));
        });
      }
    });
  }
}
export {
  E as ColumnResize
};
