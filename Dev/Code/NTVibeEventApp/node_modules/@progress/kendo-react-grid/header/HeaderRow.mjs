/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import { GridHeaderCell as O } from "./GridHeaderCell.mjs";
import { uGrid as T, classNames as o, IconWrap as V } from "@progress/kendo-react-common";
import { HeaderThElement as z } from "@progress/kendo-react-data-tools";
import { sortAriaLabel as S, messages as B } from "../messages/index.mjs";
import { sortAscSmallIcon as F, sortDescSmallIcon as j } from "@progress/kendo-svg-icons";
import { clientColumn as H, isClientReference as M, resolveCells as q } from "../utils/index.mjs";
import { GridHeaderCellContainer as v } from "./client/GridHeaderCellContainer.mjs";
import { HeaderRowDraggable as J } from "./client/HeaderRowDraggable.mjs";
import { GridHeaderRowContainer as K } from "./client/GridHeaderRowContainer.mjs";
import { GridHeaderCellElementContainer as Q } from "./client/GridHeaderCellElementContainer.mjs";
import { HeaderCellResizer as U } from "./client/HeaderCellResizer.mjs";
const X = {
  none: "none",
  asc: "ascending",
  desc: "descending"
}, oe = (e) => {
  const s = e.unstyled, c = s && s.uGrid ? s.uGrid : T;
  let y = 0, G = -1;
  const N = (n) => {
    if (!e.sort)
      return null;
    const a = o(c.sortIcon({}));
    return n >= 0 && [
      /* @__PURE__ */ t.createElement("span", { key: 1, className: a }, /* @__PURE__ */ t.createElement(
        V,
        {
          name: "sort-" + e.sort[n].dir + "-small",
          icon: e.sort[n].dir === "asc" ? F : j
        }
      )),
      e.sort.length > 1 && /* @__PURE__ */ t.createElement("span", { key: 2, className: a }, /* @__PURE__ */ t.createElement("span", { className: o(c.sortOrder({})) }, n + 1))
    ];
  }, P = (n) => n.map((a) => {
    var k;
    const l = e.columns[a], C = e.sortable && l.sortable, i = e.sort ? e.sort.findIndex((r) => r.field === l.field) : -1, w = i >= 0 && e.sort[i].dir || "none", b = l.columnMenu === null ? null : l.columnMenu || e.columnMenu, x = l.menuIcon || e.columnMenuIcon, A = o(
      o(
        c.headerTh({
          first: l.kFirst,
          filterable: !!b,
          locked: l.locked,
          sorted: e.sort && e.sort.some((r) => r.field === l.field)
        })
      ),
      l.headerClassName
    );
    l.locked === !1 && (l.left = 0);
    const D = e.localization.toLanguageString(S, B[S]), W = l.isAccessible ? {
      ariaSort: X[w],
      role: "columnheader",
      ariaColumnIndex: l.ariaColumnIndex,
      ariaSelected: !1,
      ariaDescription: C ? D : ""
    } : {
      role: "presentation"
    }, g = l.declarationIndex >= 0 ? ++G : --y, m = {
      field: l.field,
      title: l.title,
      selectionValue: (k = l.headerSelectionValue) != null ? k : e.headerSelectionValue,
      children: N(i),
      selectionChange: null,
      columnMenuWrapperProps: {
        column: {
          field: l.field,
          title: l.title,
          locked: l.locked,
          filter: l.filter,
          id: l.id
        },
        sortable: C && e.sortable,
        sort: e.sort,
        filter: e.filter,
        filterable: e.filterable && l.filterable,
        filterOperators: e.filterOperators,
        navigatable: e.navigatable,
        group: e.group,
        groupable: e.groupable,
        columnMenu: b,
        columnMenuIcon: x
      }
    }, d = {
      ...W,
      colSpan: l.headerColSpan,
      rowSpan: l.rowSpan,
      className: A,
      columnId: l.id,
      navigatable: l.navigatable,
      role: "columnheader"
    }, u = H(l), h = {
      column: u,
      sortable: e.sortable,
      sort: e.sort,
      columnMenuWrapperProps: m.columnMenuWrapperProps
    }, E = l.defaultHeaderCell ? l.defaultHeaderCell : O, I = [
      /* @__PURE__ */ t.createElement(v, { key: 1, ...h, isClient: M(E) }, /* @__PURE__ */ t.createElement(E, { ...m })),
      /* @__PURE__ */ t.createElement(U, { key: 2, column: u })
    ], f = q(e.cells, l.cells);
    if (f && f.headerCell) {
      const r = f.headerCell, L = M(r);
      return /* @__PURE__ */ t.createElement(
        v,
        {
          key: g,
          ...h,
          thProps: d,
          isCustom: !0,
          isClient: L
        },
        /* @__PURE__ */ t.createElement(r, { ...m, thProps: d, index: a }, I)
      );
    }
    return /* @__PURE__ */ t.createElement(Q, { key: g, column: u }, /* @__PURE__ */ t.createElement(z, { ...d }, I));
  }), R = e.columns.map(H);
  return /* @__PURE__ */ t.createElement(
    K,
    {
      sortable: e.sortable,
      sort: e.sort,
      navigatable: e.navigatable,
      groupable: e.groupable,
      columns: R
    },
    e.columnsMap.map((n, a) => /* @__PURE__ */ t.createElement(J, { key: a, className: o(c.simpleTr({})), ariaRowIndex: a + 1 }, P(n)))
  );
};
export {
  oe as HeaderRow
};
