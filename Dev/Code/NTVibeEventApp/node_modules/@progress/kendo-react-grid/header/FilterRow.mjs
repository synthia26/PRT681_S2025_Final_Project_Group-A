/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as i from "react";
import { GridFilterCell as v } from "../cells/GridFilterCell.mjs";
import { getFilterType as w, operatorMap as b, booleanFilterValues as P } from "../filterCommon.mjs";
import { tableKeyboardNavigationTools as R, HeaderTdElement as z } from "@progress/kendo-react-data-tools";
import { filterAriaLabel as F, messages as N } from "../messages/index.mjs";
import { classNames as A } from "@progress/kendo-react-common";
import { clientColumn as G, isClientReference as E, resolveCells as S } from "../utils/index.mjs";
import { GridFilterCellContainer as x } from "./client/GridFilterCellContainer.mjs";
import { GridFilterCellElementContainer as $ } from "./client/GridFilterCellElementContainer.mjs";
const p = "k-table-row k-filter-row", q = (t) => {
  const T = (e, r) => {
    let l = `${r ? "k-grid-header-sticky" : ""}`;
    return t.sort && t.sort.filter((o) => o.field === e).length > 0 && (l += " k-sorted"), l;
  }, h = t.filter && t.filter.filters || [], k = (e) => {
    if (e === void 0)
      return;
    const r = h.filter(
      (l) => l.field === e
    );
    return r.length ? r[0] : void 0;
  };
  let y = 0, m = -1;
  const I = t.columns.filter((e) => e.children.length === 0).map((e) => {
    const r = w(e.filter), l = k(e.field), o = `${e.field} ${t.localization.toLanguageString(
      F,
      N[F]
    )}`;
    let n = l && l.value;
    n === void 0 && (n = r === "text" ? "" : null);
    const s = e.filterable && {
      field: e.field,
      title: e.filterTitle,
      value: n,
      operator: l && l.operator,
      operators: b(t.filterOperators[r] || [], t.localization),
      booleanValues: b(P, t.localization),
      filterType: r,
      ariaLabel: e.columnType === "reorder" ? "" : o,
      size: t.size
    }, d = e.declarationIndex >= 0 ? ++m : --y, a = {
      columnId: R.getFilterColumnId(e.id),
      navigatable: e.navigatable || t.navigatable,
      className: A("k-table-td", T(e.field, e.locked) || void 0),
      role: "gridcell",
      ariaLabel: e.columnType === "reorder" ? void 0 : o,
      ariaColumnIndex: e.ariaColumnIndex
    }, C = G(e), g = {
      column: C,
      filter: t.filter,
      field: e.field,
      tdProps: a,
      thProps: a
    };
    let f = null;
    s && e.columnType !== "reorder" && (f = /* @__PURE__ */ i.createElement(x, { ...g, isClient: E(v) }, /* @__PURE__ */ i.createElement(v, { ...s })));
    const c = S(t.cells, e.cells);
    if (c && c.filterCell) {
      const u = c.filterCell, L = E(u);
      return /* @__PURE__ */ i.createElement(
        x,
        {
          key: d,
          ...g,
          isClient: L,
          isCustom: !0
        },
        /* @__PURE__ */ i.createElement(u, { key: d, ...s, tdProps: a, thProps: a, index: m }, f)
      );
    }
    return /* @__PURE__ */ i.createElement($, { key: d, column: C }, /* @__PURE__ */ i.createElement(z, { ...a }, f));
  });
  return /* @__PURE__ */ i.createElement("tr", { className: p, "aria-rowindex": t.ariaRowIndex, role: "row" }, I);
};
export {
  p as FILTER_ROW_CLASS,
  q as FilterRow
};
