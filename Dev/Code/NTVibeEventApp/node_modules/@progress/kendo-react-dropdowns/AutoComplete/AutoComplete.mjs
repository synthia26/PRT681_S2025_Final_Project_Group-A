/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as g from "react";
import c from "prop-types";
import N from "../common/SearchBar.mjs";
import R from "../common/ListContainer.mjs";
import L from "../common/List.mjs";
import S from "../common/DropDownBase.mjs";
import z from "../common/GroupStickyHeader.mjs";
import { getFilteredData as b, getItemValue as y, areSame as w, isPresent as H, getFocusedItem as M, itemIndexStartsWith as A } from "../common/utils.mjs";
import { classNames as k, Keys as m, canUseDOM as D, IconWrap as K, createPropsContext as q, withIdHOC as W, withPropsContext as G, withAdaptiveModeContext as U, kendoThemeMaps as $ } from "@progress/kendo-react-common";
import { FloatingLabel as j } from "@progress/kendo-react-labels";
import J from "../common/ClearButton.mjs";
import { AdaptiveMode as Q } from "../common/AdaptiveMode.mjs";
import E from "../common/withCustomComponent.mjs";
import { ActionSheetContent as X } from "@progress/kendo-react-layout";
import Y from "../common/ListFilter.mjs";
const Z = "Please enter a valid value!", { sizeMap: O, roundedMap: ee } = $, I = class I extends g.Component {
  constructor() {
    super(...arguments), this.state = {}, this.base = new S(this), this._element = null, this._suggested = "", this._input = null, this._adaptiveInput = null, this._skipFocusEvent = !1, this._isScrolling = !1, this.itemHeight = 0, this.focus = () => {
      this._input && this._input.focus();
    }, this.handleItemSelect = (e, t) => {
      const s = b(this.props), o = y(s[e], this.props.textField);
      this.state.text && !this.mobileMode && (this.state.text && (t.data.text = ""), this.base.filterChanged("", t)), this._adaptiveInput && this._adaptiveInput.blur(), this.triggerOnChange(o, t);
    }, this.itemFocus = (e, t) => {
      const { textField: s } = this.props, i = b(this.props)[e];
      w(this.state.focusedItem, i, s) || (t.data.focusedItem = i);
    }, this.togglePopup = (e) => {
      this.base.togglePopup(e);
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || Z
      );
    }, this.renderAdaptiveListContainer = () => {
      const { windowWidth: e = 0 } = this.state, t = /* @__PURE__ */ g.createElement(
        Y,
        {
          value: this.value,
          ref: (o) => {
            this._adaptiveInput = o && o.element;
          },
          onChange: this.onChangeHandler,
          onKeyDown: this.onInputKeyDown,
          size: "large",
          rounded: this.props.rounded,
          fillMode: this.props.fillMode,
          placeholder: this.props.placeholder
        }
      ), s = {
        title: this.props.adaptiveTitle || this.props.label,
        subTitle: this.props.adaptiveSubtitle,
        expand: this.opened,
        onClose: (o) => this.onCancel(o),
        windowWidth: e,
        mobileFilter: t
      };
      return /* @__PURE__ */ g.createElement(Q, { ...s }, /* @__PURE__ */ g.createElement(X, null, /* @__PURE__ */ g.createElement("div", { className: "k-list-container" }, this.listContainerContent())));
    }, this.onCancel = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.opened && this.base.togglePopup(t), t.events.push({ type: "onCancel" });
      const s = this.state.text;
      H(s) && s !== "" && this.base.filterChanged("", t), this.state.text && (t.data.text = ""), this.applyState(t);
    }, this.listContainerContent = () => {
      const { header: e, footer: t, size: s, groupStickyHeaderItemRender: o, groupField: i, list: a } = this.props, d = b(this.props);
      let { group: n } = this.state;
      return n === void 0 && i !== void 0 && (n = y(d[0], i)), /* @__PURE__ */ g.createElement(g.Fragment, null, e && /* @__PURE__ */ g.createElement("div", { className: "k-list-header" }, e), /* @__PURE__ */ g.createElement(
        "div",
        {
          className: k("k-list", {
            [`k-list-${this.mobileMode ? "lg" : O[s] || s}`]: s
          })
        },
        !a && n && d.length !== 0 && /* @__PURE__ */ g.createElement(z, { group: n, groupMode: "modern", render: o }),
        this.renderList()
      ), t && /* @__PURE__ */ g.createElement("div", { className: "k-list-footer" }, t));
    }, this.onScroll = (e) => {
      this._isScrolling = !0;
      const { list: t } = this.base, { groupField: s } = this.props;
      let o = b(this.props);
      if (!s || !o.length)
        return;
      const i = this.itemHeight || (t ? t.children[0].offsetHeight : 0), d = e.target.scrollTop;
      s && (o = this.base.getGroupedDataModernMode(o, s));
      let n = o[0][s];
      for (let r = 1; r < o.length && !(i * r > d); r++)
        o[r] && o[r][s] && (n = o[r][s]);
      n !== this.state.group && this.setState({
        group: n
      });
    }, this.handleItemClick = (e, t) => {
      this.base.handleItemClick(e, t), this._valueDuringOnChange = void 0;
    }, this.onChangeHandler = (e) => {
      const s = this.base.initState(), o = this.mobileMode ? e.target.element : e.currentTarget, i = o.value, a = o.selectionEnd === i.length;
      s.syntheticEvent = e;
      const d = this._suggested, n = this.value, r = n && n.substring(0, n.length - d.length), l = r && r === i, h = r && r.length > i.length, { suggest: v } = this.props, p = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      if (v !== void 0 && v !== !1) {
        l || h || !a ? this._suggested = "" : this.suggestValue(i);
        const u = i + this._suggested, f = { userInput: i, value: this._suggested };
        this.triggerOnChange(u, s, { suggestion: f });
      } else
        this._suggested = "", this.triggerOnChange(i, s);
      (!p && i || p && !i) && this.togglePopup(s), s.data.focusedItem = void 0, this.applyState(s), this.setState({ group: void 0 });
    }, this.clearButtonClick = (e) => {
      const s = this.base.initState(), o = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      s.syntheticEvent = e;
      const i = "";
      this._suggested = "", this.triggerOnChange(i, s), this.state.focusedItem !== void 0 && (s.data.focusedItem = void 0), o && this.togglePopup(s), this.applyState(s);
    }, this.onInputKeyDown = (e) => {
      const { skipDisabledItems: t, groupField: s, textField: o } = this.props, i = b(this.props);
      this._isScrolling && (this._isScrolling = !1);
      const a = this.focusedIndex(), d = i[a], n = e.keyCode, r = e.altKey, l = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = this.base.initState();
      h.syntheticEvent = e;
      const v = () => {
        l && e.preventDefault();
      };
      if (r && n === m.down)
        this.setState({
          opened: !0
        });
      else if (r && n === m.up)
        this.setState({
          opened: !1
        });
      else if (l && n === m.pageUp)
        v(), this.base.scrollPopupByPageSize(-1);
      else if (l && n === m.pageDown)
        v(), this.base.scrollPopupByPageSize(1);
      else if (l && (n === m.enter || n === m.esc))
        v(), t === !1 && d && d.disabled ? (l && this.togglePopup(h), this.applyState(h)) : this.applyInputValue(e.currentTarget.value, h, e.keyCode);
      else if (!l && n === m.esc) {
        const p = "";
        this._suggested = "", this.triggerOnChange(p, h), this.state.focusedItem !== void 0 && (h.data.focusedItem = void 0), this.applyState(h);
      } else if (n === m.up || n === m.down) {
        if (s !== "" && o)
          if (!this.props.skipDisabledItems && l)
            this.onNavigate(h, n);
          else {
            let p = 0;
            if (n === m.down || n === m.right) {
              const u = i.slice(a + 1).find((f) => !f.disabled && f[o]);
              p = u && i.findIndex((f) => f[o] === u[o]);
            } else if (n === m.up || n === m.left) {
              let u;
              if (a === -1)
                u = i, p = i.findIndex((f) => !f.disabled && f[o]);
              else {
                u = i.slice(0, a);
                let f = u.pop();
                for (; f && f.disabled; )
                  f = u.pop();
                p = f && i.findIndex((C) => C[o] === f[o]);
              }
            }
            if (p !== void 0) {
              const u = p - a;
              this.onNavigate(h, n, u);
            } else p === void 0 && i.findIndex((u) => u[o]) === i.length - 1 && this.onNavigate(h, n);
          }
        else if (!this.props.skipDisabledItems && l)
          this.onNavigate(h, n);
        else {
          let p = null;
          if (n === m.down || n === m.right)
            p = i.slice(a + 1).find((u) => !u.disabled);
          else if (n === m.up || n === m.left) {
            const u = i.slice(0, a);
            for (p = u.pop(); p && p.disabled; )
              p = u.pop();
          }
          if (p) {
            const u = p.id - a - 1;
            this.onNavigate(h, n, u);
          } else
            this.onNavigate(h, n);
        }
        this.applyState(h), v();
      }
    }, this.handleFocus = (e) => {
      this._skipFocusEvent || this.base.handleFocus(e);
    }, this.handleBlur = (e) => {
      const t = this.base.initState();
      !this.state.focused || this._skipFocusEvent || (t.syntheticEvent = e, t.data.focused = !1, t.events.push({ type: "onBlur" }), this.opened && !this.mobileMode && (this.state.opened && (t.data.opened = !1), t.events.push({ type: "onClose" })), this.applyState(t));
    }, this.handleWrapperClick = (e) => {
      const t = this._input;
      !this.opened && t && this.focusElement(t);
      const s = this.base.initState();
      s.syntheticEvent = e, !this.state.focused && !this.mobileMode && (s.events.push({ type: "onFocus" }), s.data.focused = !0), this.mobileMode && window.setTimeout(() => this._adaptiveInput && this._adaptiveInput.focus(), 300), this.base.togglePopup(s), this.applyState(s);
    };
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  get document() {
    if (D)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * The value of the AutoComplete.
   */
  get value() {
    return this._valueDuringOnChange !== void 0 ? this._valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value !== void 0 ? this.state.value : this.props.defaultValue !== void 0 ? this.props.defaultValue : "";
  }
  /**
   * Gets the `name` property of the AutoComplete.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the AutoComplete is set.
   */
  get validity() {
    const e = this.props.validationMessage !== void 0, t = !this.required || this.value !== "", s = this.props.valid !== void 0 ? this.props.valid : t;
    return {
      customError: e,
      valid: s,
      valueMissing: this.value === null
    };
  }
  /** @hidden */
  get opened() {
    return !!(this.props.opened !== void 0 ? this.props.opened : this.state.opened);
  }
  /**
   * The mobile mode of the AutoComplete.
   */
  get mobileMode() {
    var t;
    return !!(this.state.windowWidth && this.props._adaptiveMode && this.state.windowWidth <= ((t = this.props._adaptiveMode) == null ? void 0 : t.medium) && this.props.adaptive);
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : I.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : I.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidUpdate(e, t) {
    var p;
    const { groupField: s = "" } = this.props, o = b(this.props), { data: i = [] } = e, a = this.focusedIndex(), d = o[a], n = i !== o, r = d !== void 0 && t.focusedItem !== d, l = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = e.opened !== void 0 ? e.opened : t.opened, v = !h && l;
    if (s === "")
      (l && (r || n) || v) && this.base.scrollToItem(a);
    else if (!this._isScrolling) {
      const u = (p = this.base.getGroupedDataModernMode(o, s)) == null ? void 0 : p.indexOf(d);
      v && (o && o.length !== 0 && this.base.resetGroupStickyHeader(o[0][s], this), this.base.scrollToItem(u)), l && h && r && this.base.scrollToItem(u);
    }
    this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var e;
    this.observerResize = D && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.base.didMount(), this.setValidity(), (e = this.document) != null && e.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const { dir: e, disabled: t, label: s, className: o, style: i, loading: a, suggest: d, size: n, rounded: r, fillMode: l } = this.props, h = !this.validityStyles || this.validity.valid, v = this.base, p = this.value, u = this.props.clearButton !== !1 && !a && !!p, f = this.props.id || this._inputId, C = this.state.focused;
    typeof d == "string" && (this._suggested = d);
    const [P, B] = E(this.props.prefix || g.Fragment), [T, V] = E(this.props.suffix || g.Fragment), F = /* @__PURE__ */ g.createElement(g.Fragment, null, /* @__PURE__ */ g.createElement(
      "span",
      {
        className: k("k-autocomplete k-input", o, {
          [`k-input-${O[n] || n}`]: n,
          [`k-rounded-${ee[r] || r}`]: r,
          [`k-input-${l}`]: l,
          "k-invalid": !h,
          "k-focus": C && !t,
          "k-loading": a,
          "k-required": this.required,
          "k-disabled": t
        }),
        ref: (x) => {
          this._element = x, v.wrapper = x;
        },
        style: s ? { ...i, width: void 0 } : i,
        dir: e,
        onFocus: this.mobileMode ? (x) => this.handleWrapperClick(x) : this.handleFocus,
        onBlur: this.handleBlur,
        onClick: this.handleWrapperClick
      },
      this.props.prefix && /* @__PURE__ */ g.createElement(P, { ...B }),
      this.renderSearchBar(p || "", f),
      a && /* @__PURE__ */ g.createElement(K, { className: "k-input-loading-icon", name: "loading" }),
      u && !a && /* @__PURE__ */ g.createElement(J, { onClick: this.clearButtonClick, key: "clearbutton" }),
      this.props.suffix && /* @__PURE__ */ g.createElement(T, { ...V }),
      !this.mobileMode && this.renderListContainer()
    ), this.mobileMode && this.renderAdaptiveListContainer());
    return s ? /* @__PURE__ */ g.createElement(
      j,
      {
        label: s,
        editorId: f,
        editorValue: p,
        editorValid: h,
        editorDisabled: t,
        style: { width: i ? i.width : void 0 },
        children: F
      }
    ) : F;
  }
  /**
   * @hidden
   */
  onNavigate(e, t, s) {
    const o = this.value, { textField: i, focusedItemIndex: a } = this.props, d = b(this.props), n = this.state.focusedItem !== void 0 ? d.findIndex((l) => w(l, this.state.focusedItem, i)) : a ? a(d, o, i) : d.indexOf(M(d, o, i)), r = this.base.navigation.navigate({
      keyCode: t,
      current: n,
      max: d.length - 1,
      min: 0,
      skipItems: s || void 0
    });
    r !== void 0 && this.itemFocus(r, e), this.applyState(e);
  }
  /**
   * @hidden
   */
  applyInputValue(e, t, s) {
    const o = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { textField: i } = this.props, a = b(this.props), d = this.focusedIndex(), n = a[d];
    if (this._suggested = "", o && s === m.enter && n && !n.disabled) {
      const r = y(a[this.focusedIndex(e)], i);
      this.triggerOnChange(r, t);
    }
    o && this.togglePopup(t), this.applyState(t);
  }
  renderSearchBar(e, t) {
    const s = this.base, { placeholder: o, tabIndex: i, disabled: a, readonly: d, inputAttributes: n } = this.props, { focused: r } = this.state, l = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ g.createElement(
      N,
      {
        id: t,
        placeholder: o,
        tabIndex: i,
        accessKey: this.props.accessKey,
        value: e,
        suggestedText: this._suggested,
        focused: r,
        name: this.props.name,
        ref: (h) => {
          this._input = h && h.input;
        },
        onKeyDown: this.onInputKeyDown,
        onChange: this.onChangeHandler,
        onFocus: s.handleFocus,
        onBlur: this.handleBlur,
        disabled: a,
        readOnly: d,
        expanded: l,
        owns: s.listBoxId,
        activedescendant: "option-" + s.guid + "-" + this.focusedIndex(),
        role: "combobox",
        ariaLabelledBy: this.props.ariaLabelledBy,
        ariaDescribedBy: this.props.ariaDescribedBy,
        ariaRequired: this.required,
        render: this.props.valueRender,
        inputAttributes: n
      }
    );
  }
  renderListContainer() {
    const e = this.base, { dir: t, groupField: s } = this.props, o = b(this.props), i = e.getPopupSettings(), a = this.props.opened !== void 0 ? this.props.opened : this.state.opened, d = i.width !== void 0 ? i.width : e.popupWidth;
    let { group: n } = this.state;
    return n === void 0 && s !== void 0 && (n = y(o[0], s)), /* @__PURE__ */ g.createElement(
      R,
      {
        width: d,
        popupSettings: {
          ...i,
          anchor: i.anchor || this.element,
          show: a,
          popupClass: k(i.popupClass, "k-list-container", "k-autocomplete-popup")
        },
        dir: t !== void 0 ? t : this.base.dirCalculated,
        itemsCount: [o.length]
      },
      this.listContainerContent()
    );
  }
  renderList() {
    const e = this.base, t = e.getPopupSettings(), { textField: s, listNoDataRender: o, itemRender: i, groupHeaderItemRender: a } = this.props, d = b(this.props), n = this.value, r = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ g.createElement(
      L,
      {
        id: e.listBoxId,
        show: r,
        data: d.slice(),
        focusedIndex: this.focusedIndex(),
        value: n,
        textField: s,
        valueField: s,
        highlightSelected: !1,
        optionsGuid: e.guid,
        groupField: this.props.groupField,
        groupMode: "modern",
        listRef: (l) => {
          e.list = l;
        },
        wrapperStyle: this.mobileMode ? {} : { maxHeight: t.height },
        wrapperCssClass: "k-list-content",
        onClick: this.handleItemClick,
        itemRender: i,
        groupHeaderItemRender: a,
        noDataRender: o,
        onMouseDown: (l) => l.preventDefault(),
        onScroll: this.onScroll
      }
    );
  }
  triggerOnChange(e, t, s) {
    this.value === e && !s || (t.data.value = e, this._valueDuringOnChange = e, t.events.push({ type: "onChange", ...s || {} }));
  }
  focusElement(e) {
    this._skipFocusEvent = !0, e.focus(), window.setTimeout(() => this._skipFocusEvent = !1, 0);
  }
  applyState(e) {
    this.base.applyState(e), this._valueDuringOnChange = void 0;
  }
  suggestValue(e) {
    if (this._suggested = "", e) {
      const { textField: t } = this.props, s = b(this.props), o = s[A(s, e, t)];
      if (o) {
        const i = y(o, t);
        e.toLowerCase() !== i.toLowerCase() && (this._suggested = i.substring(e.length));
      }
    }
  }
  focusedIndex(e) {
    const { textField: t, focusedItemIndex: s, skipDisabledItems: o } = this.props, i = b(this.props), a = e !== void 0 ? e : this.value;
    if (this.state.focusedItem !== void 0)
      return i.findIndex((n) => w(n, this.state.focusedItem, t));
    if (s)
      return s(i, a, t);
    const d = i.indexOf(M(i, a, t));
    return o && t && d === -1 ? i.findIndex((n) => !n.disabled && n[t]) : Math.max(0, d);
  }
  calculateMedia(e) {
    for (const t of e)
      this.setState({ windowWidth: t.target.clientWidth });
  }
};
I.displayName = "AutoComplete", I.propTypes = {
  ...S.basicPropTypes,
  size: c.oneOf([null, "small", "medium", "large"]),
  rounded: c.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: c.oneOf([null, "solid", "flat", "outline"]),
  groupField: c.string,
  suggest: c.oneOfType([c.bool, c.string]),
  placeholder: c.string,
  value: c.string,
  defaultValue: c.string,
  validationMessage: c.string,
  required: c.bool,
  readonly: c.bool,
  clearButton: c.bool,
  valueRender: c.func,
  id: c.string,
  ariaLabelledBy: c.string,
  ariaDescribedBy: c.string,
  list: c.any,
  adaptive: c.bool,
  adaptiveTitle: c.string,
  adaptiveSubtitle: c.string,
  onCancel: c.func,
  skipDisabledItems: c.bool,
  inputAttributes: c.object
}, I.defaultProps = {
  ...S.defaultProps,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  skipDisabledItems: !0,
  prefix: void 0,
  suffix: void 0
};
let _ = I;
const te = q(), se = W(
  G(
    te,
    U(_)
  )
);
se.displayName = "KendoReactAutoComplete";
export {
  se as AutoComplete,
  te as AutoCompletePropsContext,
  _ as AutoCompleteWithoutContext
};
