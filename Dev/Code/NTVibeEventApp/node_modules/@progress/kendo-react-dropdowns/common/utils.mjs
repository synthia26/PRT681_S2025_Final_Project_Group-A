/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l = (e) => e != null, d = (e, t) => {
  for (let r = 0; r < e.length; r++)
    if (e.charAt(r) !== t)
      return !1;
  return !0;
}, I = (e, t, r) => {
  let n = e;
  return r && (n = [r].concat(n)), n.slice(t).concat(n.slice(0, t));
}, x = (e, t, r) => {
  if (!l(e))
    return !1;
  let n = String(e);
  return r && (n = n.toLowerCase()), n.indexOf(t) === 0;
}, C = (e, t, r, n, o) => {
  const s = e.offsetHeight, g = t.children.item(r), f = g.offsetTop + (o ? n - e.scrollTop : 0), c = g.offsetHeight;
  if (o) {
    let u = 0;
    f + c > s ? u = f + c - s : f < 0 && (u = f), u !== 0 ? e.scrollTop += u : e.scrollTop === 0 && n !== 0 && (e.scrollTop = n);
  } else
    f + c > s + e.scrollTop ? e.scrollTop = f + c - s : f < e.scrollTop && (e.scrollTop -= e.scrollTop - f);
}, h = (e, t, r) => {
  let n = -1;
  if (t) {
    t = t.toLowerCase();
    for (let o = 0; o < e.length; o++) {
      const s = (i(e[o], r) || "") + "";
      if (s && s.toLowerCase().startsWith(t)) {
        n = o;
        break;
      }
    }
  }
  return n;
}, T = (e, t, r, n = !1) => {
  const o = (s) => n ? s : s.toLowerCase();
  return e.findIndex((s) => r ? o(i(s, r)) === o(t) : o(t) === o(s.toString()));
}, i = (e, t) => {
  if (t && l(e)) {
    const r = t.split(".");
    let n = e;
    return r.forEach((o) => {
      n = n ? n[o] : void 0;
    }), n;
  }
  return e;
}, D = (e, t, r) => {
  if (!e)
    return;
  const n = e.findIndex((o) => i(o, t) === r);
  return e[n];
}, a = (e = [], t = [], r) => {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!p(e[n], t[n], r))
      return !1;
  return !0;
}, w = (e, t, r) => {
  t.forEach((n) => {
    const o = e.findIndex((s) => p(s, n, r));
    o !== -1 && e.splice(o, 1);
  });
}, p = (e, t, r) => e === t || l(e) === l(t) && i(e, r) === i(t, r), L = (e, t, r) => {
  if (t) {
    const n = T(e, t, r, !0);
    return n !== -1 ? e[n] : e[h(e, t, r)];
  }
  return e[0];
}, H = (e, t = [], r) => {
  let n = "";
  if (e) {
    const o = t[h(t, e, r)];
    if (o) {
      const s = i(o, r);
      e.toLowerCase() !== s.toLowerCase() && (n = s.substring(e.length));
    }
  }
  return n;
}, S = (e) => {
  e.target.nodeName !== "INPUT" && e.preventDefault();
}, y = (e, t, r) => !!e != !!t || e.text !== t.text ? !1 : e === t || a(e.data, t.data, r), N = (e) => {
  const t = e.filter(
    (r, n) => e.some((o, s) => o === r && s !== n)
  );
  return Array.from(new Set(t));
}, O = (e) => {
  const { data: t = [], groupField: r } = e;
  return r ? t.filter((n) => r && n[r] !== void 0) : t;
};
export {
  p as areSame,
  D as findByFieldValue,
  O as getFilteredData,
  L as getFocusedItem,
  T as getItemIndexByText,
  i as getItemValue,
  N as getPlainDataDuplicates,
  l as isPresent,
  h as itemIndexStartsWith,
  a as matchDataCollections,
  y as matchTags,
  x as matchText,
  S as preventDefaultNonInputs,
  w as removeDataItems,
  d as sameCharsOnly,
  C as scrollToItem,
  I as shuffleData,
  H as suggestValue
};
