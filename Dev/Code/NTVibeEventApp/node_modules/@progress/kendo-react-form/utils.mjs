/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const f = " ";
function p(r) {
  let e = r.clientWidth;
  const n = getComputedStyle(r);
  return e -= (parseFloat(n.paddingLeft) || 0) + (parseFloat(n.borderLeftWidth) || 0), e -= (parseFloat(n.paddingRight) || 0) + (parseFloat(n.borderRightWidth) || 0), e;
}
function c(r, e) {
  var n, l;
  if (!(r != null && r.length) || e == null)
    return "";
  for (const [o, s] of r.entries()) {
    const t = o > 0 && r[o - 1].maxWidth !== void 0 ? r[o - 1].maxWidth : void 0, i = o < r.length - 1 && r[o + 1].minWidth !== void 0 ? r[o + 1].minWidth : void 0, d = (n = s.minWidth) != null ? n : t !== void 0 ? t + 1 : 0, a = (l = s.maxWidth) != null ? l : i !== void 0 ? i - 1 : 1 / 0;
    if (e >= d && e <= a)
      return s.value;
  }
  return "";
}
const u = (r) => {
  if (typeof r == "number")
    return `${r}px`;
  if (typeof r == "string") {
    const e = r.trim(), n = parseInt(e, 10);
    return !isNaN(n) && Number.isFinite(n) ? n.toString() === e ? `${n}px` : r : null;
  }
  return null;
}, y = (r, e) => {
  if (!r)
    return null;
  if (Array.isArray(r) && r.length > 0) {
    const n = c(r, e) || null;
    return typeof n == "string" ? parseInt(n, 10) : n;
  } else if (typeof r == "number")
    return r;
  return null;
}, w = (r) => r && r > 0 ? `k-grid-cols-${r}` : "", h = (r, e) => {
  if (!r)
    return null;
  if (typeof r == "number")
    return r;
  if (Array.isArray(r) && r.length > 0) {
    const n = c(r, e) || null;
    return typeof n == "string" ? parseInt(n, 10) : n;
  }
  return null;
}, m = (r) => r ? `k-col-span-${r}` : "", A = (r, e) => {
  if (!r)
    return null;
  if (typeof r == "number")
    return { cols: r, rows: r };
  if (typeof r == "string") {
    if (!r.includes(f))
      return { cols: r, rows: r };
    const n = r.split(f);
    return { cols: n[1], rows: n[0] };
  } else if (Array.isArray(r)) {
    const n = c(r, e) || null;
    return n !== null ? { cols: n, rows: n } : null;
  } else if (typeof r == "object") {
    const n = r, l = { rows: null, cols: null };
    return n.cols !== void 0 && n.cols !== null ? typeof n.cols == "number" || typeof n.cols == "string" ? l.cols = n.cols : Array.isArray(n.cols) && (l.cols = c(n.cols, e) || null) : l.cols = null, n.rows !== void 0 ? typeof n.rows == "number" || typeof n.rows == "string" ? l.rows = n.rows : Array.isArray(n.rows) && (l.rows = c(n.rows, e) || null) : l.rows = null, l;
  }
  return null;
}, C = (r, e) => {
  var o, s, t, i;
  const n = u((s = (o = r == null ? void 0 : r.rows) != null ? o : e.rows) != null ? s : "0px"), l = u((i = (t = r == null ? void 0 : r.cols) != null ? t : e.cols) != null ? i : "32px");
  return `${n} ${l}`;
};
export {
  h as calculateColSpan,
  y as calculateColumns,
  A as calculateGutters,
  m as generateColSpanClass,
  w as generateColumnClass,
  C as generateGuttersStyling,
  p as innerWidth,
  c as processBreakpoints,
  u as processCssValue
};
