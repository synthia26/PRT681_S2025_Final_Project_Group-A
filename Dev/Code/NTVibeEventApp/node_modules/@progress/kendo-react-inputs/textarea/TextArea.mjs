/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import e from "prop-types";
import { createPropsContext as fe, usePropsContext as me, useCustomComponent as M, useId as pe, useDir as be, useIsomorphicLayoutEffect as ge, dispatchEvent as y, classNames as S, getTabIndex as xe, kendoThemeMaps as A } from "@progress/kendo-react-common";
const ve = fe(), w = t.forwardRef((N, H) => {
  const n = me(ve, N), {
    size: c = d.size,
    rounded: f = d.rounded,
    fillMode: k = d.fillMode,
    autoFocus: R = d.autoFocus,
    prefix: $ = null,
    suffix: q = null,
    ariaDescribedBy: D,
    ariaLabelledBy: L,
    autoSize: C,
    className: j,
    defaultValue: K,
    disabled: r,
    readOnly: G,
    required: l,
    rows: J,
    id: Q,
    name: U,
    placeholder: W,
    style: X,
    tabIndex: Y,
    value: m,
    valid: z,
    validationMessage: F,
    validityStyles: I,
    onChange: p,
    onFocus: b,
    onBlur: g,
    // Removed to support direct use in Form Field component
    visited: he,
    touched: ye,
    modified: ke,
    resizable: x,
    inputAttributes: Z,
    ..._
  } = n, a = t.useRef(null), E = t.useCallback(() => {
    a.current && a.current.focus();
  }, []), O = t.useCallback(() => {
    a.current && a.current.blur();
  }, []), [P, T] = t.useState(K), [ee, V] = t.useState(!1), [te, ae] = M($), [re, se] = M(q), u = m !== void 0, i = u ? m : P, s = t.useCallback(() => ({
    element: a,
    focus: E,
    blur: O,
    get value() {
      return i;
    },
    get name() {
      return a.current && a.current.name;
    }
  }), [O, E, i]);
  t.useImperativeHandle(H, s);
  const [oe, B] = t.useState("auto"), ne = pe(), le = be(a, n.dir), v = z !== void 0 ? z : l ? !!i : !0;
  t.useEffect(() => {
    a.current && a.current.setCustomValidity && a.current.setCustomValidity(v ? "" : F || "");
  }, [v, F]), ge(() => {
    a.current && B(`${a.current.scrollHeight}px`);
  }, [i]);
  const ue = t.useCallback(
    (o) => {
      const h = o.target.value;
      B("auto"), !u && !r && T(h), p && !r && y(
        p,
        o,
        {
          ...s(),
          value: h
        },
        { value: h }
      );
    },
    [T, p, r, u]
  ), ie = t.useCallback(
    (o) => {
      V(!0), b && !r && y(b, o, s(), void 0);
    },
    [b, r, s]
  ), de = t.useCallback(
    (o) => {
      V(!1), g && !r && y(g, o, s(), void 0);
    },
    [g, r, s]
  ), ce = {
    id: Q || ne,
    role: "textbox",
    name: U,
    className: S("k-input-inner", "!k-overflow-auto", { "k-resize": !C && x !== "none" }),
    ref: a,
    disabled: r,
    rows: J,
    placeholder: W,
    readOnly: G,
    required: l,
    tabIndex: xe(Y, r),
    autoFocus: R,
    style: C ? { resize: "none", overflow: "hidden", height: oe } : x ? { resize: x } : {},
    "aria-labelledby": L,
    "aria-describedby": D,
    "aria-multiline": !0,
    "aria-disabled": r || void 0,
    "aria-required": l,
    value: u ? m : P,
    ...Object.assign({}, _, Z),
    onChange: ue,
    onFocus: ie,
    onBlur: de
  };
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      className: S(
        "k-input",
        "k-textarea",
        {
          [`k-input-${A.sizeMap[c] || c}`]: c,
          [`k-input-${k}`]: k,
          [`k-rounded-${A.roundedMap[f] || f}`]: f,
          "k-invalid": !(v || I !== void 0 || I === !0),
          "k-required": l,
          "k-disabled": r,
          "k-focus": ee
        },
        j
      ),
      style: X,
      dir: le
    },
    n.prefix && /* @__PURE__ */ t.createElement(te, { ...ae }),
    /* @__PURE__ */ t.createElement("textarea", { ...ce }),
    n.suffix && /* @__PURE__ */ t.createElement(re, { ...se })
  );
});
w.propTypes = {
  ariaDescribedBy: e.string,
  ariaLabelledBy: e.string,
  autoSize: e.bool,
  className: e.string,
  defaultValue: e.string,
  dir: e.string,
  disabled: e.bool,
  readOnly: e.bool,
  rows: e.number,
  id: e.string,
  name: e.string,
  placeholder: e.string,
  style: e.object,
  tabIndex: e.number,
  value: e.oneOfType([e.string, e.arrayOf(e.string), e.number]),
  onChange: e.func,
  onFocus: e.func,
  onBlur: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  resizable: e.oneOf(["none", "both", "horizontal", "vertical"]),
  autoFocus: e.bool
};
const d = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  autoFocus: !1
};
w.displayName = "KendoTextArea";
export {
  w as TextArea,
  ve as TextAreaPropsContext
};
