/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as t from "react";
import r from "prop-types";
import { createPropsContext as Ue, validatePackage as Ke, getLicenseMessage as $e, usePropsContext as Ge, useAdaptiveModeContext as Me, canUseDOM as Ze, Navigation as je, getActiveElement as qe, keepFocusInContainer as z, focusFirstFocusableChild as de, WatermarkOverlay as Je, useDir as Qe, classNames as Z, kendoThemeMaps as pe, getTabIndex as Xe, IconWrap as Ye, svgIconPropType as et } from "@progress/kendo-react-common";
import { packageMetadata as fe } from "../package-metadata.mjs";
import { Picker as tt } from "./Picker.mjs";
import { ColorGradient as nt } from "./ColorGradient.mjs";
import { ColorPalette as at, DEFAULT_PRESET as rt, DEFAULT_TILE_SIZE as ot } from "./ColorPalette.mjs";
import { FlatColorPicker as B } from "./FlatColorPicker.mjs";
import { Button as lt } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as it } from "@progress/kendo-svg-icons";
import { colorPickerAdaptiveTitle as me, messages as L, flatColorPickerCancelBtn as ge, flatColorPickerApplyBtn as ve, colorPickerDropdownButtonAriaLabel as ke } from "../messages/index.mjs";
import { useLocalization as ct } from "@progress/kendo-react-intl";
import { AdaptiveMode as st } from "../common/AdaptiveMode.mjs";
import { ActionSheetContent as ut } from "@progress/kendo-react-layout";
const dt = {
  opacity: !0
}, pt = {
  palette: rt,
  tileSize: ot
}, j = (D) => D !== void 0, ft = Ue(), Ce = t.forwardRef((D, Ee) => {
  var oe, le;
  const be = !Ke(fe, { component: "ColorPicker" }), we = $e(fe), o = Ge(ft, D), b = ct(), q = Me(), {
    size: u = k.size,
    rounded: x = k.rounded,
    fillMode: _ = k.fillMode,
    gradientSettings: C = k.gradientSettings,
    paletteSettings: w = k.paletteSettings,
    flatColorPickerSettings: y,
    view: d = o.views ? void 0 : k.view,
    views: c = d ? void 0 : k.views,
    activeView: J,
    popupSettings: g,
    valid: ye,
    disabled: N,
    tabIndex: Se,
    icon: O,
    svgIcon: F,
    iconClassName: P,
    onChange: V,
    onFocus: H,
    onBlur: W,
    onActiveColorClick: U,
    className: he,
    adaptive: _e,
    adaptiveTitle: Q = b.toLanguageString(me, L[me])
  } = o, s = t.useRef(null), S = t.useRef(null), T = t.useRef(null), m = t.useRef(null), E = t.useRef(void 0), Pe = t.useRef(null), [Te, X] = t.useState(!1), [Re, Ae] = t.useState(o.defaultValue || void 0), [Ie, ze] = t.useState(!1), [R, Be] = t.useState(), K = j(o.value), v = j(o.open), l = K ? o.value : Re, p = v ? o.open : Ie, Y = t.useRef(l), ee = t.useCallback(() => {
    s.current && s.current.focus();
  }, []);
  t.useImperativeHandle(
    Ee,
    () => ({
      // we agreed that each element will have focus method exposed
      element: s.current,
      actionElement: Pe.current,
      value: l,
      focus: ee
    }),
    [l, ee]
  );
  const $ = !!(R && q && R <= q.medium && _e);
  t.useEffect(() => {
    const e = Ze && window.ResizeObserver && new window.ResizeObserver(He.bind(void 0));
    return document != null && document.body && e && e.observe(document.body), () => {
      document != null && document.body && e && e.disconnect();
    };
  }, []);
  const a = t.useCallback(
    (e, i) => {
      v || (!e && !i && s && s.current && s.current.focus(), ze(e));
    },
    [v]
  ), te = t.useMemo(() => new je({
    root: s,
    selectors: [".k-colorpicker", ".k-color-picker-popup"],
    tabIndex: 0,
    keyboardEvents: {
      keydown: {
        Escape: (e, i, n) => {
          a(!1);
        },
        Enter: (e, i, n) => {
          !v && e === s.current && (n.preventDefault(), n.stopPropagation(), a(!0));
        },
        ArrowDown: (e, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), a(!0));
        },
        ArrowUp: (e, i, n) => {
          n.altKey && (n.preventDefault(), n.stopPropagation(), a(!1));
        },
        Tab: (e, i, n) => {
          var h, ie, ce;
          if (qe(document) !== s.current) {
            const se = (h = T.current) == null ? void 0 : h.wrapperRef.current, I = (ie = S.current) == null ? void 0 : ie.wrapperRef.current, ue = (ce = m.current) == null ? void 0 : ce.element;
            d === "palette" && se ? z(n, se) : d === "gradient" && I ? z(n, I) : d === "combo" && I ? z(n, I.parentElement) : c && ue && z(n, ue);
          }
        }
      }
    }
  }), [a, v]), Le = t.useCallback(te.triggerKeyboardEvent.bind(te), []), De = t.useCallback(() => {
    v || (S.current && S.current.wrapperRef.current ? de(S.current.wrapperRef.current) : T.current ? T.current.focus() : m.current && m.current.element && de(m.current.element));
  }, [v]), A = (e) => Y.current = e, ne = t.useCallback(
    (e) => {
      const i = {
        value: Y.current,
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      };
      f(i), a(!p, !0);
    },
    [p]
  ), G = t.useCallback(() => {
    a(!1, !0);
  }, [a]), xe = t.useCallback(
    (e) => {
      U && U.call(void 0, {
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        value: l,
        target: {
          element: s.current,
          value: l
        }
      });
    },
    [U, l]
  ), Ne = t.useCallback(
    (e) => {
      E.current ? (clearTimeout(E.current), E.current = void 0) : (X(!0), $ && !p && a(!0)), H && H.call(void 0, {
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      });
    },
    [$, H, p, a]
  ), Oe = t.useCallback(() => {
    a(!1, !0), X(!1), E.current = void 0;
  }, []), Fe = t.useCallback(
    (e) => {
      clearTimeout(E.current), E.current = window.setTimeout(Oe), W && W.call(void 0, {
        nativeEvent: e.nativeEvent,
        syntheticEvent: e
      });
    },
    [W]
  ), f = t.useCallback(
    (e, i) => {
      var h;
      const n = i ? e.rgbaValue || "" : (h = e.value) != null ? h : "";
      K || Ae(n), V && V.call(void 0, {
        value: n,
        nativeEvent: e.nativeEvent,
        syntheticEvent: e.syntheticEvent,
        target: {
          element: s.current,
          value: n
        }
      }), a(!1);
    },
    [K, V]
  ), ae = t.useCallback(
    (e) => f(e, !0),
    [j, f]
  ), M = t.useCallback(
    (e) => /* @__PURE__ */ t.createElement(t.Fragment, null, (d === "combo" || d === "gradient") && /* @__PURE__ */ t.createElement(
      nt,
      {
        ...C,
        _adaptive: e,
        ref: S,
        isInsidePopup: !0,
        size: e ? "large" : u,
        fillMode: _,
        value: l,
        onChange: f
      }
    ), (d === "combo" || d === "palette") && /* @__PURE__ */ t.createElement(
      at,
      {
        ...w,
        ref: T,
        size: e ? "large" : u,
        value: l,
        onChange: ae
      }
    ), c && c[0] === "gradient" && c[1] === "palette" && /* @__PURE__ */ t.createElement(
      B,
      {
        ...y,
        _paletteSettings: w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: m,
        size: e ? "large" : u,
        views: ["gradient", "palette"],
        activeView: J,
        setOpen: a,
        showButtons: !e,
        value: l,
        onChange: f,
        setAdaptiveModeValue: A
      }
    ), c && c[0] === "palette" && c[1] === "gradient" && /* @__PURE__ */ t.createElement(
      B,
      {
        ...y,
        _paletteSettings: w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: m,
        size: e ? "large" : u,
        views: ["palette", "gradient"],
        setOpen: a,
        showButtons: !e,
        value: l,
        onChange: f,
        setAdaptiveModeValue: A
      }
    ), c && c.includes("gradient") && !c.includes("palette") && /* @__PURE__ */ t.createElement(
      B,
      {
        ...y,
        _gradientSettings: { _adaptive: e, ...C },
        ref: m,
        size: e ? "large" : u,
        views: ["gradient"],
        showButtons: !e,
        setOpen: a,
        value: l,
        onChange: f,
        setAdaptiveModeValue: A
      }
    ), c && c.includes("palette") && !c.includes("gradient") && /* @__PURE__ */ t.createElement(
      B,
      {
        ...y,
        _paletteSettings: w,
        _gradientSettings: { _adaptive: e, ...C },
        ref: m,
        size: e ? "large" : u,
        views: ["palette"],
        showButtons: !e,
        setOpen: a,
        value: l,
        onChange: f,
        setAdaptiveModeValue: A
      }
    ), be && /* @__PURE__ */ t.createElement(Je, { message: we })),
    [
      J,
      _,
      y,
      C,
      f,
      ae,
      w,
      a,
      u,
      l,
      d,
      c
    ]
  ), Ve = t.useCallback(() => {
    var i;
    const e = {
      animation: !!((i = g == null ? void 0 : g.animate) == null || i),
      title: Q,
      expand: p,
      onClose: G,
      windowWidth: R,
      footer: {
        cancelText: b.toLanguageString(ge, L[ge]),
        onCancel: G,
        applyText: b.toLanguageString(ve, L[ve]),
        onApply: ne
      }
    };
    return /* @__PURE__ */ t.createElement(st, { ...e }, /* @__PURE__ */ t.createElement(ut, null, M(!0)));
  }, [
    g == null ? void 0 : g.animate,
    Q,
    p,
    G,
    R,
    b,
    ne,
    M
  ]), He = t.useCallback((e) => {
    for (const i of e)
      Be(i.target.clientWidth);
  }, []), re = Qe(s, o.dir), We = ye !== !1;
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      id: o.id,
      role: "combobox",
      "aria-label": o.ariaLabel,
      "aria-labelledby": o.ariaLabelledBy,
      "aria-describedby": o.ariaDescribedBy,
      "aria-haspopup": "dialog",
      "aria-expanded": p,
      "aria-controls": `k-colorpicker-popup-${(oe = o.id) != null ? oe : 0}`,
      "aria-disabled": N ? "true" : void 0,
      className: Z("k-colorpicker", "k-picker", "k-icon-picker", {
        [`k-picker-${pe.sizeMap[u] || u}`]: u,
        [`k-picker-${_}`]: _,
        [`k-rounded-${pe.roundedMap[x] || x}`]: x,
        "k-invalid": !We,
        "k-disabled": N,
        "k-focus": Te,
        className: he
      }),
      ref: s,
      tabIndex: Xe(Se, N),
      title: o.title,
      onKeyDown: Le,
      onFocus: Ne,
      onBlur: Fe,
      dir: re
    },
    /* @__PURE__ */ t.createElement(
      tt,
      {
        dir: re,
        open: p,
        onOpen: De,
        popupAnchor: s.current || void 0,
        popupSettings: { id: `k-colorpicker-popup-${(le = o.id) != null ? le : 0}`, ...g },
        input: /* @__PURE__ */ t.createElement("span", { onClick: xe, className: "k-input-inner" }, /* @__PURE__ */ t.createElement(
          "span",
          {
            className: Z("k-value-icon", "k-color-preview", {
              "k-no-color": !l,
              "k-icon-color-preview": O || F || P
            })
          },
          P && /* @__PURE__ */ t.createElement("span", { className: Z("k-color-preview-icon", P) }),
          !P && (O || F) && /* @__PURE__ */ t.createElement(Ye, { name: O, icon: F }),
          /* @__PURE__ */ t.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: l } })
        )),
        button: /* @__PURE__ */ t.createElement(
          lt,
          {
            tabIndex: -1,
            type: "button",
            onClick: () => a(!p),
            className: "k-input-button",
            rounded: null,
            icon: "caret-alt-down",
            svgIcon: it,
            "aria-label": b.toLanguageString(
              ke,
              L[ke]
            )
          }
        ),
        content: M(!1),
        _mobileMode: $,
        _actionSheet: Ve()
      }
    )
  );
});
Ce.propTypes = {
  value: r.string,
  defaultValue: r.string,
  disabled: r.bool,
  view: r.oneOf(["gradient", "palette", "combo"]),
  views: r.arrayOf(r.oneOf(["gradient", "palette"])),
  dir: r.string,
  id: r.string,
  icon: r.string,
  svgIcon: et,
  ariaLabelledBy: r.string,
  ariaDescribedBy: r.string,
  size: r.oneOf([null, "small", "medium", "large"]),
  rounded: r.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: r.oneOf([null, "solid", "flat", "outline"]),
  className: r.string,
  adaptive: r.bool,
  adaptiveTitle: r.string,
  adaptiveSubtitle: r.string
};
const k = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  view: "palette",
  views: ["gradient", "palette"],
  gradientSettings: dt,
  paletteSettings: pt
};
Ce.displayName = "KendoColorPicker";
export {
  Ce as ColorPicker,
  ft as ColorPickerPropsContext
};
