/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { FOCUSABLE_ELEMENTS as b, TABBABLE_ELEMENTS as y } from "@progress/kendo-react-common";
import { KEYBOARD_NAV_DATA_LEVEL as f, KEYBOARD_NAV_DATA_ID as g, KEYBOARD_NAV_DATA_SCOPE as D, KEYBOARD_NAV_CANCEL_BUTTON_CLASS as B, KEYBOARD_NAV_EDIT_BUTTON_CLASS as w, KEYBOARD_NAV_DATA_HEADER as S, KEYBOARD_NAV_DATA_BODY as h, KEYBOARD_NAV_FILTER_COL_SUFFIX as T } from "./constants.mjs";
const $ = (e, t, r = "cell") => `${t}_${e}_${r}`, k = (e) => {
  if (e)
    return parseInt(e.getAttribute(f) || "", 10);
}, I = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(g);
  return t || void 0;
}, E = (e) => e ? !!e.getAttribute(g) : !1, F = (e, t = { level: 0 }) => e.querySelector(`[${f}='${t.level}']`), _ = (e) => e && e.parentElement && e.parentElement.closest(`[${f}]`), m = (e, t) => e.querySelector(`[${g}='${t}']`), L = (e) => e && e.parentElement && e.parentElement.closest(`[${D}]`), R = (e) => {
  var r;
  const t = ((r = e == null ? void 0 : e.parentElement) == null ? void 0 : r.closest(".k-grid-edit-row")) || null;
  return t == null ? void 0 : t.querySelector("." + B);
}, q = (e) => document.querySelector(`[aria-rowindex="${e}"] .k-grid-remove-command`), a = (e) => document.querySelector(`[data-keyboardnavid="${e}"]`), O = (e) => {
  var n;
  const t = e && e.parentElement && e.parentElement.closest(".k-table-row");
  let r;
  return (n = t == null ? void 0 : t.parentElement) == null || n.childNodes.forEach((l) => {
    if (t === l) {
      const o = l.previousSibling;
      r = {
        current: t.getAttribute("aria-rowindex"),
        prev: o && o.getAttribute("aria-rowindex")
      };
    }
  }), r;
};
async function p(e, t, r = 5e3) {
  const n = Date.now();
  if (t)
    for (; Date.now() - n < r; ) {
      const l = t.querySelector(e);
      if (l)
        return l;
      await new Promise((o) => setTimeout(o, 20));
    }
  return !1;
}
const K = async (e) => {
  var n;
  const t = ((n = e == null ? void 0 : e.parentElement) == null ? void 0 : n.closest(".k-grid-edit-row")) || null;
  return await p("." + w, t);
}, V = (e) => (e == null ? void 0 : e.closest(".k-table-td")) || null, Y = (e) => e.querySelector(`[${S}]`), P = (e) => e.querySelector(`[${h}]`), le = (e) => e.querySelector(".k-grid-norecords"), oe = (e) => {
  const t = e.querySelector(".k-grid-edit-cell"), r = t == null ? void 0 : t.querySelector("input");
  r ? r.focus() : t && t.firstChild.focus();
}, U = (e, t) => {
  const { scope: r, navigationStateRef: n, contextStateRef: l } = e;
  if (!n.current || !r)
    return;
  const o = Q(n.current.navigationMatrix), s = m(r, o);
  x({ elementForFocus: s, contextStateRef: l, event: t });
}, j = (e, t = { focusable: !1 }) => {
  const r = t.focusable ? b : y;
  return Array.from(e.querySelectorAll(r.join(",")));
}, W = (e, t = { level: 0 }) => {
  if (!e)
    return [];
  const r = b.map((n) => n + `[${f}='${t.level}']`).join(",");
  return Array.from(e.querySelectorAll(r));
}, H = (e = { level: 0 }) => {
  const t = b.map((r) => r + `[${f}='${e.level}']`).join(",");
  return (r) => r.matches(t);
}, x = (e) => {
  const { elementForFocus: t, event: r, contextStateRef: n, prevElement: l } = e;
  if (n.current && t && t.focus) {
    r == null || r.preventDefault();
    const o = t.querySelector(".k-checkbox-wrap .k-checkbox");
    o && o.focus ? o.focus() : t.focus(), E(t) && (t.setAttribute("tabIndex", "0"), n.current.activeId = I(t)), l && E(l) && l.setAttribute("tabIndex", "-1");
  }
}, M = (e) => e.current ? e.current.idPrefix : "", X = (e, t, r, n, l) => {
  if (!r)
    return [];
  let o = e + (l ? -1 : 1);
  for (; o >= 0 && o < n.length; ) {
    const s = n[o][t];
    if (s !== r)
      return [s, [o, t]];
    o = o + (l ? -1 : 1);
  }
  return [];
}, d = (e, t, r, n, l) => {
  if (!r)
    return [];
  let o = t + (l ? -1 : 1);
  for (; o >= 0 && n[e] && o < n[e].length; ) {
    const s = n[e][o];
    if (s !== r)
      return [s, [e, o]];
    o = o + (l ? -1 : 1);
  }
  return [];
}, A = (e, t) => {
  if (t) {
    for (let r = 0; r < e.length; r++)
      for (let n = 0; n < e[r].length; n++)
        if (e[r][n] === t)
          return [r, n];
  }
}, C = (e, t, r) => {
  let n;
  do
    if (e = e + 1, n = t[r - e], n && n.editable)
      break;
  while (r - e >= 0);
  return n;
}, z = (e, t, r, n) => {
  var v;
  let l;
  const [o, s] = e;
  let c;
  const i = 0, u = t.length;
  return c = C(i, t, s), c ? l = d(o, c.ariaColumnIndex, r, n, !0) : (c = C(i, t, u), l = d(o - 1, c.ariaColumnIndex, r, n, !0)), {
    prevCell: l && l[0] && a(l[0]),
    elementToFocus: l && l[0] && ((v = a(l[0])) == null ? void 0 : v.getAttribute("role"))
  };
}, N = (e, t, r) => {
  let n;
  do
    if (e = e + 1, n = t[r + e], n && n.editable)
      break;
  while (r + e - 1 < t.length);
  return n;
}, G = (e, t, r, n) => {
  var o;
  let l;
  if (e) {
    const [s, c] = e;
    let i, u = 0;
    i = N(u, t, c), i ? l = d(s, i.ariaColumnIndex, r, n, !0) : (u = -1, i = N(u, t, 0), l = d(s + 1, i.ariaColumnIndex, r, n, !0));
  }
  return {
    nextCell: l && l[0] && a(l[0]),
    elementToFocus: l && l[0] && ((o = a(l[0])) == null ? void 0 : o.getAttribute("role"))
  };
}, J = (e) => e.current ? e.current.navigationMatrix.length : 0, Q = (e) => e.flat().find((t) => t.endsWith("cell")), se = (e) => e.flat().reverse().find((t) => t.endsWith("cell")), ce = (e, t) => e[t][0], ie = (e, t) => Array.from(e[t]).reverse()[0], Z = (e) => e ? `${e}${T}` : "", ue = (e, t, r) => {
  var l;
  let n;
  if ((l = e.current) != null && l.prevNavigationIndexes) {
    const [o, s] = e.current.prevNavigationIndexes, c = t[o];
    c && c[s] === r ? n = e.current.prevNavigationIndexes : n = A(t, r);
  } else
    n = A(t, r);
  return n;
}, ee = (e) => {
  var t;
  return ((t = _(e)) == null ? void 0 : t.getAttribute("data-keyboardnavid")) || e.getAttribute("data-keyboardnavid");
}, ae = {
  generateNavigatableId: $,
  getNavigatableId: I,
  getNavigatableLevel: k,
  getNavigatableElement: F,
  getClosestNavigatableElement: _,
  getActiveNavDataElement: m,
  getClosestScope: L,
  getHeaderElement: Y,
  getBodyElement: P,
  getFocusableElements: j,
  getNavigatableElements: W,
  filterNavigatableElements: H,
  focusElement: x,
  getIdPrefix: M,
  isNavigatable: E,
  findNextIdByRowIndex: X,
  findNextIdByCellIndex: d,
  findId: A,
  getNextNavigationIndex: J,
  getFilterColumnId: Z,
  focusFirstDataElement: U,
  getClosestCancelButton: R,
  getClosestEditButton: K,
  getRowAriaRowIndex: O,
  getRemoveButtonByAriaRowIndex: q,
  getTableCellByKeyboardNavId: a,
  getParentCell: V,
  waitForElementToBeVisible: p,
  getNextEditableCell: G,
  getPrevEditableCell: z,
  getClosestCellNavId: ee
};
export {
  H as filterNavigatableElements,
  A as findId,
  d as findNextIdByCellIndex,
  X as findNextIdByRowIndex,
  x as focusElement,
  U as focusFirstDataElement,
  oe as focusFirstEditor,
  $ as generateNavigatableId,
  m as getActiveNavDataElement,
  P as getBodyElement,
  R as getClosestCancelButton,
  ee as getClosestCellNavId,
  K as getClosestEditButton,
  _ as getClosestNavigatableElement,
  L as getClosestScope,
  ue as getCurrentIdIndexes,
  Z as getFilterColumnId,
  Q as getFirstDataCell,
  ce as getFirstRowDataCell,
  j as getFocusableElements,
  Y as getHeaderElement,
  M as getIdPrefix,
  se as getLastDataCell,
  ie as getLastRowDataCell,
  F as getNavigatableElement,
  W as getNavigatableElements,
  I as getNavigatableId,
  k as getNavigatableLevel,
  G as getNextEditableCell,
  J as getNextNavigationIndex,
  le as getNoRecordsElement,
  V as getParentCell,
  z as getPrevEditableCell,
  q as getRemoveButtonByAriaRowIndex,
  O as getRowAriaRowIndex,
  a as getTableCellByKeyboardNavId,
  E as isNavigatable,
  ae as tableKeyboardNavigationTools
};
