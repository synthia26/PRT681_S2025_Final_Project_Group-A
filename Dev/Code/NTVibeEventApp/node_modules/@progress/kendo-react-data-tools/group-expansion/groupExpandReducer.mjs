/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var w = /* @__PURE__ */ ((e) => (e.TOGGLE = "GROUP-EXPAND_TOGGLE", e.EXPAND = "GROUP-EXPAND_EXPAND", e.COLLAPSE = "GROUP-EXPAND_COLLAPSE", e.RESET = "GROUP-EXPAND_RESET", e))(w || {});
const U = (e) => {
  var r;
  return {
    enabled: typeof e == "boolean" ? e : (r = e == null ? void 0 : e.enabled) != null ? r : !0,
    defaultExpand: typeof e == "object" ? e == null ? void 0 : e.defaultExpand : !0
  };
}, E = (e = [], r = null) => {
  const u = [];
  return e == null || e.forEach((d) => {
    var s;
    const l = {
      value: d.value,
      field: d.field,
      parents: r ? [r, ...(s = r.parents) != null ? s : []] : []
    };
    d.expanded !== void 0 && (l.expanded = d.expanded), d.groups && u.push(...E(d.groups, l)), u.push(l);
  }), u;
}, h = (e) => {
  var r, u, d, l;
  return `${(r = e.parents) != null && r.length ? ((l = (d = (u = e.parents) == null ? void 0 : u.slice()) == null ? void 0 : d.reverse()) == null ? void 0 : l.map((s) => h({ field: s.field, value: s.value })).join("/")) + "/" : ""}${e.field}:${e.value}`;
}, F = (e, r) => {
  const u = E(e);
  return x(u, r);
}, $ = (e, r) => {
  var l;
  const u = E(e), d = x(u, r);
  return d ? (l = d.expanded) != null ? l : !0 : !1;
}, o = (e) => {
  var l;
  const r = /* @__PURE__ */ new Map();
  r.set("root", { value: null, field: "", groups: /* @__PURE__ */ new Set() }), ((s) => {
    s.forEach((f) => {
      var p, P, g, G;
      const c = h(f), a = (p = r.get(c)) != null ? p : {
        value: f.value,
        field: f.field
      };
      f.expanded !== void 0 && (a.expanded = f.expanded), r.has(c) || r.set(c, a);
      let n = a;
      (P = f.parents) != null && P.length ? f.parents.forEach((v, L) => {
        var A, O, D, R, S, X, T;
        const i = h({
          value: v.value,
          field: v.field,
          parents: (O = f.parents) == null ? void 0 : O.slice(L + 1, (A = f == null ? void 0 : f.parents) == null ? void 0 : A.length)
        }), t = (D = r.get(i)) != null ? D : {
          value: v.value,
          field: v.field
        };
        v.expanded && (t.expanded = v.expanded), r.has(i) || r.set(i, t), t != null && t.groups || (t.groups = /* @__PURE__ */ new Set()), t.groups.add(n), n = t, L === ((S = (R = f.parents) == null ? void 0 : R.length) != null ? S : -1) - 1 && ((T = (X = r.get("root")) == null ? void 0 : X.groups) == null || T.add(t));
      }) : (G = (g = r.get("root")) == null ? void 0 : g.groups) == null || G.add(n);
    });
  })(e);
  const d = (s) => {
    s.groups && (s.groups = Array.from(s.groups), s.groups.forEach(d));
  };
  return d(r.get("root")), ((l = r.get("root")) == null ? void 0 : l.groups) || [];
}, N = (e, r) => {
  var u;
  return !!((u = r.parents) != null && u.every((d, l) => {
    var s;
    return (s = e.parents) == null ? void 0 : s.find((f) => d.value === f.value && d.field === f.field);
  }));
}, x = (e, r) => e.find((d) => d.value === r.value && d.field === r.field && N(d, r)), j = (e, r, u) => {
  var s, f, c;
  const d = E(e != null ? e : []), l = x(d, r.group);
  switch (r.type) {
    case "GROUP-EXPAND_TOGGLE":
      return o(
        l ? d == null ? void 0 : d.map(
          (a) => {
            var n, p;
            return a === l ? {
              ...a,
              expanded: !((p = (n = a.expanded) != null ? n : u == null ? void 0 : u.defaultExpand) == null || p)
            } : a;
          }
        ) : [...d, { ...r.group, expanded: !((s = u == null ? void 0 : u.defaultExpand) == null || s) }]
      );
    case "GROUP-EXPAND_EXPAND": {
      let a;
      return l ? a = d == null ? void 0 : d.map((n) => n === l ? { ...n, expanded: !0 } : n) : (f = u == null ? void 0 : u.defaultExpand) == null || f ? a = d : a = [...d, { ...r.group, expanded: !0 }], o(a);
    }
    case "GROUP-EXPAND_COLLAPSE": {
      let a;
      return l ? a = d == null ? void 0 : d.map((n) => n === l ? { ...n, expanded: !1 } : n) : (c = u == null ? void 0 : u.defaultExpand) == null || c ? a = [...d, { ...r.group, expanded: !1 }] : a = d, o(a);
    }
    default:
      return e;
  }
};
export {
  w as GROUP_EXPAND_ACTION,
  F as findGroupExpand,
  o as flatToTree,
  U as getGroupExpandableOptions,
  j as groupExpandReducer,
  $ as isExpanded
};
