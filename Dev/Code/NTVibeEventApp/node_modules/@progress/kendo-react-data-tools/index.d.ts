/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { BaseEvent } from '@progress/kendo-react-common';
import { ComponentType } from 'react';
import { CompositeFilterDescriptor } from '@progress/kendo-data-query';
import { default as default_2 } from 'prop-types';
import { DropDownListProps } from '@progress/kendo-react-dropdowns';
import { FilterComponentProps as FilterComponentProps_2 } from './FilterComponentProps';
import { FilterDescriptor } from '@progress/kendo-data-query';
import { GroupDescriptor } from '@progress/kendo-data-query';
import { JSX } from 'react/jsx-runtime';
import * as React_2 from 'react';
import { SortDescriptor } from '@progress/kendo-data-query';
import { State } from '@progress/kendo-data-query';
import { SVGIcon } from '@progress/kendo-react-common';

/**
 * @hidden
 */
export declare const addHeaders: (initialData: string, cols: string[], event: ClipboardDataEvent) => string;

/**
 * Represents the base object of the `onPageChange` event. It is usually used
 * in custom pager scenarios in cases when we don't need any of the events or the target.
 */
export declare interface BasePageChangeEvent {
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
    /**
     * A React Synthetic Event.
     */
    syntheticEvent?: React.SyntheticEvent<any>;
    /**
     * A native DOM event.
     */
    nativeEvent?: any;
    /**
     * A target change event.
     */
    targetEvent?: PagerTargetEvent;
}

/**
 * The BooleanFilter component used for editing boolean value of FilterDescriptor object.
 */
export declare class BooleanFilter extends React_2.Component<BooleanFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: default_2.Validator<object>;
        onFilterChange: default_2.Validator<(...args: any[]) => any>;
        data: default_2.Requireable<(default_2.InferProps<{
            text: default_2.Requireable<string>;
            value: default_2.Requireable<any>;
        }> | null | undefined)[]>;
        ariaLabel: default_2.Requireable<string>;
        defaultItem: default_2.Requireable<any>;
    };
    private data;
    /**
     * @hidden
     */
    render(): JSX.Element;
}

/**
 * @hidden
 */
export declare class BooleanFilterCell extends BooleanFilterCell_base {
}

declare const BooleanFilterCell_base: React_2.ComponentClass<FilterComponentProps_2, any>;

/**
 * The props of the BooleanFilter component.
 */
export declare interface BooleanFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the BooleanFilter DropDownList.
     * Defaults to [ { text: 'True', value: true }, { text: 'False', value: false } ]
     */
    data?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the BooleanFilter DropDownList.
     */
    defaultItem?: any;
}

export declare interface CellProps {
    /**
     * @hidden
     */
    id: string;
    /**
     * The index applied to the `aria-colindex` attribute.
     */
    ariaColumnIndex: number;
    /**
     * Indicates if the cell is selected.
     */
    isSelected: boolean;
    /** @hidden */
    isHighlighted?: boolean;
    /** @hidden */
    isInEdit?: boolean;
    /**
     * Indicates if the cell is sorted.
     */
    isSorted?: boolean;
    /**
     * Indicates if the cell is alt.
     */
    isAlt?: boolean;
    /**
     * Indicates if the cell is expanded.
     */
    expanded?: boolean;
    /**
     * Custom CSS classes for the cell.
     */
    className?: string;
    /**
     * Inline styles for the cell.
     */
    style?: React_2.CSSProperties;
    /**
     * The data field that the cell binds to.
     */
    field?: string;
    /**
     * The data item for the current row.
     */
    dataItem: any;
    /**
     * The format applied to the value before display.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format.
     */
    format?: string;
    /**
     * The column span of the cell.
     */
    colSpan?: number;
    /**
     * Fires when the cell is selected.
     */
    selectionChange?: (event: {
        syntheticEvent: React_2.SyntheticEvent<any>;
    }) => void;
    /**
     * Fires when the cell value changes.
     */
    onChange?: (event: {
        dataItem: any;
        syntheticEvent: React_2.SyntheticEvent<any>;
        field?: string;
        value?: any;
    }) => void;
    /**
     * Overrides the default cell rendering.
     */
    render?: (defaultRendering: React_2.ReactElement<HTMLTableCellElement> | null, props: CellProps) => React_2.ReactElement<HTMLTableCellElement> | null;
}

/**
 * The possible values of the  `type` property.
 */
export declare enum ClipboardActionType {
    copy = "copy",
    cut = "cut",
    paste = "paste"
}

/**
 * Represents the object that is returned form the `populateClipboardData` function.
 */
export declare interface ClipboardData {
    /**
     * A collection of the ClipboardItem that are selected.
     */
    copiedItems: ClipboardItem_2[];
    /**
     * A collection of the ClipboardItem that are pasted.
     */
    pastedItems: ClipboardItem_2[];
    /**
     * When the action is `copy` or `cut` - the Grid data, copied to the clipboard, in Excel-compatible format.
     * When the action is `paste` - the current clipboard data, available in the original DOM event.
     */
    clipboardData: string;
}

/**
 * Represents the object of the `ClipboardDataEvent` event.
 */
export declare interface ClipboardDataEvent {
    /**
     * Represents the type of the clipboard action.
     */
    type: ClipboardActionType;
    /**
     * Represents the native [ClipboardEvent]({% slug api_grid_gridcellssettings %})
     */
    nativeEvent?: ClipboardEvent;
    /**
     * All the Grid columns. It takes value of type of [ColumnBaseProps]({% slug api_data-tools_columnbaseprops %})&lt;[CellProps]({% slug api_data-tools_cellprops %})&gt;[]
     */
    columns: ColumnBaseProps[];
    /**
     * Passes the dataItemKey prop in the clipboard action.
     */
    dataItemKey: string;
    /**
     * Passes the clipboard prop copyHeaders value in the clipboard action.
     */
    copyHeaders?: boolean;
    /**
     * Sets the cell delimiter used when manipulating the clipboard data Defaults to `\t`.
     */
    cellDelimiter?: string;
    /**
     * Sets the row delimiter used when manipulating the clipboard data Defaults to `\r\n`.
     */
    newLineDelimiter?: string;
    /**
     * This is the item that is clicked if the action is raised from the contextMenu.
     */
    dataItem?: any;
    /**
     *  This is the column field that is clicked if the action is raised from the contextMenu.
     */
    field?: string;
}

/**
 * Represents the aria that is copied - the dataItem and the fields.
 */
declare interface ClipboardItem_2 {
    /**
     * Represents the dataItem used in the clipboard action.
     */
    dataItem: any;
    /**
     * Represents the fields used in the clipboard action.
     */
    fields: string[];
}
export { ClipboardItem_2 as ClipboardItem }

/**
 * @hidden
 */
export declare class ClipboardService {
    private clipboardEvent;
    constructor(ClipboardEventHandler: (clipboardType: ClipboardActionType, event: ClipboardEvent) => void);
    private copyHandler;
    private cutHandler;
    private pasteHandler;
    addEventListeners: (document: Document | undefined) => void;
    removeEventListeners: (document: Document | undefined) => void;
}

/**
 * Represents settings that can be added to the clipboard behavior.
 */
export declare interface ClipboardSettings {
    /**
     * Determines whether column titles or field names will be included in the generated data
     * during the `copy` and `cut` actions.
     * Defaults to `false`.
     */
    copyHeaders: boolean;
    /**
     * Determines what is the delimiter used to separate the cells.
     * Defaults to `\t`.
     */
    cellDelimiter?: string;
    /**
     * Determines what is the delimiter used to separate the rows.
     * Defaults to `'\r\n'`.
     */
    newLineDelimiter?: string;
}

/** @hidden */
export declare const closestTagName: (target: HTMLElement | null, tagName: 'TD' | 'TR' | 'TABLE') => HTMLElement | null;

export declare interface ColumnBaseProps<C = CellProps> {
    /**
     * Sets the data field that the column binds to.
     */
    field?: string;
    /**
     * Sets the column header text.
     */
    title?: string;
    /**
     * Enables header click to emit the `sortChange` event. Handle `sortChange` to sort the data.
     *
     * @default true
     */
    sortable?: boolean | ColumnSortSettings;
    /**
     * Sets the width of the column (in pixels).
     */
    width?: string | number;
    /**
     * Indicates that the header selection checkbox is checked when `true`.
     */
    headerSelectionValue?: boolean;
    /**
     * Applies a format to the value before display.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format. For more information on supported formats see the
     * [kendo-intl](https://github.com/telerik/kendo-intl/blob/develop/docs/index.md) documentation.
     */
    format?: string;
    /**
     * Sets custom CSS classes on the header cell.
     */
    headerClassName?: string;
    /**
     * Sets custom CSS classes on the column cells.
     */
    className?: string;
    /**
     * Enables column resizing when `true`.
     *
     * @default true
     */
    resizable?: boolean;
    /**
     * Enables column reordering when `true`.
     *
     * @default true
     */
    reorderable?: boolean;
    /**
     * Sets the minimum resize width (in pixels).
     *
     * @default 10
     */
    minResizableWidth?: number;
    /**
     * Determines the column position. Smaller `orderIndex` values render first.
     *
     * @default 0
     */
    orderIndex?: number;
    /**
     * Sets the column id for distinguishing columns (multi header, resize, or keyboard navigation scenarios).
     * Also used as the unique key for rendering cells. If not set, a unique id is generated.
     */
    id?: string;
    /**
     * Defines the component rendered as a cell. If not set, a `Cell` renders.
     */
    cell?: ComponentType<C>;
    /**
     * @hidden
     */
    navigatable?: boolean;
    /**
     * @hidden
     */
    locked?: boolean;
}

/**
 * @hidden
 */
export declare const ColumnDefaultProps: {
    filterable: boolean;
    editable: boolean;
    sortable: boolean;
    resizable: boolean;
    reorderable: boolean;
    groupable: boolean;
};

/**
 * @hidden
 */
declare interface ColumnDraggableProps {
    pressHandler?: (draggableEvent: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    dragHandler?: (draggableEvent: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    releaseHandler?: (draggableEvent: any) => void;
    ariaRowIndex?: number;
    children?: React_2.ReactNode;
}

/**
 * Represents the ColumnMenuBooleanColumn component. Use it for `boolean` type columns.
 */
export declare const ColumnMenuBooleanColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuBooleanFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * Represents the ColumnMenuDateColumn component. Use it for `Date` type columns.
 */
export declare const ColumnMenuDateColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuDateFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * @hidden
 */
export declare const ColumnMenuFilterForm: React_2.FunctionComponent<ColumnMenuFormProps>;

export declare const ColumnMenuFilterLogic: React_2.FunctionComponent<DropDownListProps>;

export declare interface ColumnMenuFilterProps {
    /** The current filter descriptor for the column */
    filter: FilterDescriptor;
    /** Event handler for filter changes */
    onFilterChange: (event: React_2.SyntheticEvent<any>, nextFilter: FilterDescriptor, prevFilter: FilterDescriptor) => void;
    /** Available filter operators for the column */
    operators?: {
        text: string;
        operator: string;
    }[];
    /** Initial filter descriptor when creating a new filter */
    initialFilter?: FilterDescriptor;
    /** Custom input component for filter value entry */
    input?: React_2.ComponentType<{
        value: any;
        onChange: any;
    }>;
}

export declare const ColumnMenuForm: React_2.FunctionComponent<ColumnMenuFormProps>;

export declare interface ColumnMenuFormProps {
    /** Whether to show the form */
    show?: boolean;
    /** Event handler for form submission */
    onSubmit?: React_2.FormEventHandler<HTMLFormElement>;
    /** Event handler for form reset */
    onReset?: React_2.FormEventHandler<HTMLFormElement>;
    /** Action buttons or custom action elements */
    actions?: React_2.ReactNode;
    /** Form content and child elements */
    children?: React_2.ReactNode;
}

export declare const ColumnMenuItem: React_2.FunctionComponent<ColumnMenuItemProps>;

/**
 * Defines the props of the ColumnMenuItem component.
 */
export declare interface ColumnMenuItemProps {
    /**
     * Fires when the item is clicked.
     */
    onClick?: (event: React_2.MouseEvent<HTMLDivElement>) => void;
    /**
     * Indicates that the item is selected when `true`.
     */
    selected?: boolean;
    /**
     * Disables the item when `true`.
     */
    disabled?: boolean;
    /**
     * Sets the font icon CSS class.
     */
    iconClass?: string;
    /**
     * Sets the SVG icon definition.
     */
    svgIcon?: SVGIcon;
    /**
     * Sets the item title text.
     */
    title: string;
}

/**
 * Represents the ColumnMenuNumericColumn component. Use it for `number` type columns.
 */
export declare const ColumnMenuNumericColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuNumericFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * Represents the operators for the ColumnMenuTextFilter, ColumnMenuNumericFilter,
 * ColumnMenuDateFilter and ColumnMenuBooleanFilter components.
 *
 * The text field of each operator object will be resolved according to the
 * [localization messages]({% slug globalization_datatools %}#toc-messages).
 */
export declare class ColumnMenuOperators {
    /**
     * An array containing the operators for the ColumnMenuTextFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterContainsOperator', operator: 'contains' }
     * - { text: 'columnMenu.filterNotContainsOperator', operator: 'doesnotcontain' }
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterStartsWithOperator', operator: 'startswith' }
     * - { text: 'columnMenu.filterEndsWithOperator', operator: 'endswith' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     * - { text: 'columnMenu.filterIsEmptyOperator', operator: 'isempty' }
     * - { text: 'columnMenu.filterIsNotEmptyOperator', operator: 'isnotempty' }
     */
    static get text(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuNumericFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterGteOperator', operator: 'gte' }
     * - { text: 'columnMenu.filterGtOperator', operator: 'gt' }
     * - { text: 'columnMenu.filterLteOperator', operator: 'lte' }
     * - { text: 'columnMenu.filterLtOperator', operator: 'lt' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     */
    static get numeric(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuDateFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterAfterOrEqualOperator', operator: 'gte' }
     * - { text: 'columnMenu.filterAfterOperator', operator: 'gt' }
     * - { text: 'columnMenu.filterBeforeOperator', operator: 'lt' }
     * - { text: 'columnMenu.filterBeforeOrEqualOperator', operator: 'lte' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     */
    static get date(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuBooleanFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterIsTrue', operator: '' }
     */
    static get boolean(): FilterOperator[];
}

/**
 * Defines the props of the ColumnMenu component.
 */
export declare interface ColumnMenuProps {
    /**
     * Sets the `SortDescriptor[]` applied to the data.
     */
    sort?: SortDescriptor[];
    /**
     * Fires when sorting changes. Receives the browser event, the new `SortDescriptor[]`, and the column `field`.
     */
    onSortChange?: (event: React_2.SyntheticEvent<any>, sort: SortDescriptor[], field: string) => void;
    /**
     * Sets the `CompositeFilterDescriptor[]` applied to the data.
     */
    filter?: CompositeFilterDescriptor[];
    /**
     * Fires when filtering changes. Receives the browser event, the new `CompositeFilterDescriptor[]`, and the column `field`.
     */
    onFilterChange?: (event: React_2.SyntheticEvent<any>, filter: CompositeFilterDescriptor[], field: string) => void;
    /**
     * Sets the column `field` the menu operates on.
     */
    field?: string;
    /**
     * Shows the ascending sort button when `true`.
     *
     * @default false
     */
    sortAsc?: boolean;
    /**
     * Shows the descending sort button when `true`.
     *
     * @default false
     */
    sortDesc?: boolean;
    /**
     * Provides the filtering UI components in render order. Supply up to three components: first filter, logic, second filter.
     */
    filterContent?: any[];
    /**
     * Sets the initial expand state of the filters.
     *
     * @default false
     */
    expandFilters?: boolean;
    /**
     * Returns the initial `CompositeFilterDescriptor` based on the current `field`. Use to customize starting filter values.
     */
    initialFilter?: (field: string) => CompositeFilterDescriptor;
    /**
     * Fires before the ColumnMenu items render. Use to add or remove items.
     * `defaultRendering` holds sorting and filtering elements.
     * `props` exposes the column `field` and `closeMenu()` helper.
     */
    itemsRender?: (defaultRendering: (React_2.ReactElement<HTMLDivElement> | null)[], props: {
        field?: string;
        closeMenu: () => void;
    }) => React_2.ReactNode;
    /**
     * Fires before the ColumnMenu renders. Use to override the entire rendering.
     * `defaultRendering` contains the menu button and popup elements (and license watermark when present).
     */
    render?: (defaultRendering: React_2.ReactElement<any>[]) => React_2.ReactNode;
}

/**
 * Represents the ColumnMenuTextColumn component. Use it for `string` type columns.
 */
export declare const ColumnMenuTextColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuTextFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * @hidden
 */
export declare class ColumnResize<C = CellProps, H = HeaderCellProps, F = FilterCellProps> {
    /**
     * The main `colgroup` of the Grid.
     */
    colGroupMain: any | null;
    /**
     * The header `colgroup` of the Grid (if any).
     */
    colGroupHeader: any | null;
    /**
     * The footer `colgroup` of the Grid (if any).
     */
    colGroupFooter: any | null;
    columns: ExtendedColumnProps<C, H, F>[];
    /**
     * The settings for resizing the Grid.
     */
    resizable: boolean;
    onResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void;
    private isRtl;
    constructor(triggerResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void);
    setIsRtl: (isRtl: boolean) => void;
    dragHandler(event: any, column: ExtendedColumnProps<C, H, F>, dragCue: HTMLSpanElement, end: boolean): void;
    private setWidths;
    private updateColElements;
    private setColWidth;
}

/**
 * @hidden
 */
export declare class ColumnResizer extends React_2.Component<ColumnResizerResizerProps, {}> {
    private draggable;
    private isDragged;
    /**
     * @hidden
     */
    onDrag: (data: any) => void;
    /**
     * @hidden
     */
    onRelease: (data: any) => void;
    /**
     * @hidden
     */
    onDoubleClick: (event: React_2.MouseEvent<HTMLSpanElement, MouseEvent>) => void;
    render(): JSX.Element;
}

/**
 * @hidden
 */
declare interface ColumnResizerResizerProps {
    resize: (event: any, dragCue: HTMLSpanElement, end: boolean) => void;
    autofit?: (event: React_2.MouseEvent<HTMLSpanElement, MouseEvent>, dragCue: HTMLSpanElement) => void;
}

/**
 * The settings for sorting the columns of the component.
 */
export declare interface ColumnSortSettings {
    /**
     * Enables the removal of the column sorting functionality.
     */
    allowUnsort?: boolean;
}

/** @hidden */
export declare const combineFilters: (first?: CompositeFilterDescriptor, second?: CompositeFilterDescriptor) => CompositeFilterDescriptor | undefined;

/**
 * @hidden
 */
export declare class CommonDragLogic<C = CellProps, H = HeaderCellProps, F = FilterCellProps> {
    columns: ExtendedColumnProps<C, H, F>[];
    reorderable: boolean;
    groupable: boolean;
    private startColumn;
    private startGroup;
    private currentColumn;
    private currentGroup;
    private columnReorder;
    private groupReorder;
    private columnToGroup;
    private dropElementClue;
    private dragElementClue;
    private groupPanelDivElement;
    constructor(columnReorder: handler, groupReorder: handler, columnToGroup: handler);
    refGroupPanelDiv: (e: HTMLDivElement | null) => void;
    refDropElementClue: (e: DropClue | null) => void;
    refDragElementClue: (e: DragClue | null) => void;
    pressHandler: (event: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    dragHandler: (event: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    releaseHandler: (event: any) => void;
    private getColumnIndex;
    private getGroupIndex;
    private isValid;
    private updateDragElementClue;
    private updateDropElementClue;
}

/**
 * Creates a tree from the passed dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {(item: object) => any} getId - A function which will return the id of the data item.
 * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are structured in a tree.
 */
export declare const createDataTree: (dataset: any[], getId: (item: any) => any, getParentId: (item: any) => any, subItemsField: string) => any[];

/**
 * @hidden
 */
export declare const createFilterComponent: (settings: FilterComponentSettings) => React_2.ComponentClass<FilterComponentProps, any>;

/**
 * @hidden
 */
declare interface DataItemWrapper {
    dataItem: any;
    level: number[];
    height: number;
    offsetTop: number;
    levelCount: number;
}

/**
 * Represents a data source with data presentation operations (filtering, sorting, paging, grouping).
 *
 * @template T - The type of data items in the data source. Defaults to any.
 */
export declare type DataSource<T extends object = any> = {
    /** The array of data items. */
    data: T[];
    /**
     * Sets the data items in the data source.
     *
     * @param value - The array of new data items.
     */
    setData: (value: T[]) => void;
    /** The total number of data items. */
    total: number;
    /** The schema used for data validation and transformation. */
    schema: DataSourceProps<T>['schema'];
    /** The current sort descriptors applied to the data. */
    sort: SortDescriptor[] | undefined;
    /**
     * Sets the sort descriptors for the data.
     *
     * @param value - The new sort descriptors.
     */
    setSort: (value: SortDescriptor[] | undefined) => void;
    /** The current filter descriptor applied to the data. */
    filter: CompositeFilterDescriptor | undefined;
    /**
     * Sets the filter descriptor for the data.
     *
     * @param value - The new filter descriptor.
     */
    setFilter: (value: CompositeFilterDescriptor | undefined) => void;
    /** The current skip value for pagination. */
    skip: number | undefined;
    /**
     * Sets the skip value for pagination.
     *
     * @param value - The new skip value.
     */
    setSkip: (value: number | undefined) => void;
    /** The current take value for pagination. */
    take: number | undefined;
    /**
     * Sets the take value for pagination.
     *
     * @param value - The new take value.
     */
    setTake: (value: number | undefined) => void;
    /** The current group descriptors applied to the data. */
    group: GroupDescriptor[] | undefined;
    /**
     * Sets the group descriptors for the data.
     *
     * @param value - The new group descriptors.
     */
    setGroup: (value: GroupDescriptor[] | undefined) => void;
    /** The current data state, including sorting, filtering, and pagination. */
    dataState: Partial<DataSourceProps<T>>;
    /**
     * Sets the data state, including sorting, filtering, and pagination.
     *
     * @param dataState - The new data state.
     */
    setDataState: (dataState: Partial<DataSourceProps<T>>) => void;
    /**
     * Sets the total number of data items.
     *
     * @param value - The new total value.
     */
    setTotal: (value: number | undefined) => void;
};

/**
 * Describes the options for configuring the useDataSource hook.
 *
 * @template T - The type of data items in the data source. Defaults to any.
 */
export declare type DataSourceProps<T extends object = any> = {
    /**
     * The total number of records in the data source.
     */
    total?: number;
    /**
     * The initial total number of records in the data source.
     */
    defaultTotal?: number;
    /**
     * The current data array to be managed by the hook.
     * This represents the data items that are currently available in the data source.
     * If not provided, the `defaultData` will be used as the initial value.
     */
    data?: T[];
    /**
     * The initial data array to be managed by the hook.
     */
    defaultData?: T[];
    /**
     * The current sorting configuration.
     */
    sort?: SortDescriptor[];
    /**
     * The initial sorting configuration.
     */
    defaultSort?: SortDescriptor[];
    /**
     * The current filter configuration.
     */
    filter?: CompositeFilterDescriptor;
    /**
     * The initial filter configuration.
     */
    defaultFilter?: CompositeFilterDescriptor;
    /**
     * The current number of records to skip (for paging).
     */
    skip?: number;
    /**
     * The initial number of records to skip (for paging).
     */
    defaultSkip?: number;
    /**
     * The current number of records to take per page.
     */
    take?: number;
    /**
     * The initial number of records to take per page.
     */
    defaultTake?: number;
    /**
     * The current grouping configuration.
     */
    group?: GroupDescriptor[];
    /**
     * The initial grouping configuration.
     */
    defaultGroup?: GroupDescriptor[];
    /**
     * Specifies whether filtering is enabled.
     *
     * @default true
     */
    filterable?: boolean;
    /**
     * Specifies whether sorting is enabled.
     *
     * @default true
     */
    sortable?: boolean;
    /**
     * Specifies whether paging is enabled.
     *
     * @default true
     */
    pageable?: boolean;
    /**
     * Specifies whether grouping is enabled.
     *
     * @default true
     */
    groupable?: boolean;
    /**
     * Configuration for the data schema, including model definition.
     */
    schema: {
        model: {
            /**
             * The field that serves as the unique identifier for records.
             */
            id: string;
        };
    };
};

/**
 * The DateFilter component used for editing date value of FilterDescriptor object.
 */
export declare class DateFilter extends React_2.Component<DateFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: default_2.Validator<object>;
        onFilterChange: default_2.Validator<(...args: any[]) => any>;
        ariaLabel: default_2.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class DateFilterCell extends DateFilterCell_base {
}

declare const DateFilterCell_base: React_2.ComponentClass<FilterComponentProps_2, any>;

/**
 * The props of the DateFilter component.
 */
export declare interface DateFilterProps extends TextFilterProps {
}

/** @hidden */
export declare enum DETAIL_EXPAND_ACTION {
    DETAIL_EXPAND = "DETAIL_EXPAND_DETAIL_EXPAND",
    COLLAPSE = "DETAIL_EXPAND_COLLAPSE",
    TOGGLE = "DETAIL_EXPAND_TOGGLE",
    SET = "DETAIL_EXPAND_SET"
}

/** @hidden */
export declare type DetailExpandAction = {
    type: DETAIL_EXPAND_ACTION.TOGGLE | DETAIL_EXPAND_ACTION.DETAIL_EXPAND | DETAIL_EXPAND_ACTION.COLLAPSE;
    id: string;
} | {
    type: DETAIL_EXPAND_ACTION.SET;
    id: string;
    payload: boolean;
};

/**
 * The descriptor used to define the expanded state of the detail-row.
 */
export declare type DetailExpandDescriptor = {
    [id: string]: boolean;
};

/** @hidden */
export declare const detailExpandReducer: (state: DetailExpandDescriptor, action: DetailExpandAction) => DetailExpandDescriptor;

/**
 * @hidden
 */
export declare class DragClue extends React_2.PureComponent<any, DragClueState> {
    private elementRef;
    readonly state: DragClueState;
    hiddenElementRef: React_2.RefObject<HTMLDivElement | null>;
    get element(): HTMLDivElement | null;
    constructor(props: any);
    render(): JSX.Element;
}

/**
 * @hidden
 */
declare interface DragClueState {
    visible: boolean;
    top: number;
    left: number;
    innerText: string;
    status: 'k-i-cancel' | 'k-i-plus';
}

/**
 * @hidden
 */
export declare class DropClue extends React_2.PureComponent<any, DropClueState> {
    readonly state: DropClueState;
    hiddenElementRef: React_2.RefObject<HTMLDivElement | null>;
    constructor(props: any);
    render(): JSX.Element;
}

/**
 * @hidden
 */
declare interface DropClueState {
    visible: boolean;
    top: number;
    left: number;
    height: number;
}

/**
 * @hidden
 */
export declare enum EDIT_ACTION {
    ENTER_EDIT = "EDITING_ENTER_EDIT",
    ENTER_FIELD_EDIT = "EDITING_ENTER_FIELD_EDIT",
    ADD_EDIT = "EDITING_ADD_EDIT",
    ADD_FIELD_EDIT = "EDITING_ADD_FIELD_EDIT",
    EXIT_EDIT = "EDITING_EXIT_EDIT",
    EXIT_FIELD_EDIT = "EDITING_EXIT_FIELD_EDIT",
    TOGGLE_EDIT = "EDITING_TOGGLE_EDIT",
    TOGGLE_FIELD_EDIT = "EDITING_TOGGLE_FIELD_EDIT"
}

/**
 * @hidden
 */
export declare type EditAction = {
    type: EDIT_ACTION.ENTER_EDIT | EDIT_ACTION.ADD_EDIT | EDIT_ACTION.EXIT_EDIT | EDIT_ACTION.TOGGLE_EDIT;
    payload: {
        id: string;
    };
} | {
    type: EDIT_ACTION.ENTER_FIELD_EDIT | EDIT_ACTION.ADD_FIELD_EDIT | EDIT_ACTION.EXIT_FIELD_EDIT | EDIT_ACTION.TOGGLE_FIELD_EDIT;
    payload: {
        id: string;
        field: string;
    };
};

/**
 * The `edit` descriptor used to identify which data-items are in edit mode.
 *
 * @example
 * ```ts
 * const data = [
 *   { id: 0, name: 'Jane Doe' },
 *   { id: 1, name: 'John Doe' }
 * ]
 *
 * const edit = {
 *  1: true
 * }
 * ```
 */
export declare type EditDescriptor = {
    /**
     * The data-item id is in edit mode.
     * If the value is `true` if the whole item (row) is in edit mode.
     * If the value is an array of strings if only specific fields (cells) are in edit mode.
     */
    [id: string]: boolean | string[];
};

/**
 * @hidden
 */
export declare const editReducer: (state: EditDescriptor | undefined, action: EditAction) => EditDescriptor;

/**
 * The EnumFilter component used for editing the value of FilterDescriptor object.
 * It renders a DropDownList and allows you to choose a value from the predefined list.
 */
export declare class EnumFilter extends React_2.Component<EnumFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: default_2.Validator<object>;
        onFilterChange: default_2.Validator<(...args: any[]) => any>;
        data: default_2.Requireable<(default_2.InferProps<{
            text: default_2.Requireable<string>;
            value: default_2.Requireable<any>;
        }> | null | undefined)[]>;
        defaultItem: default_2.Requireable<any>;
        ariaLabel: default_2.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX.Element;
    private onChange;
}

/**
 * The props of the EnumFilter component.
 */
export declare interface EnumFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the EnumFilter DropDownList.
     */
    data?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the EnumFilter DropDownList.
     */
    defaultItem?: any;
}

/**
 * @hidden
 */
export declare class Expression extends React_2.Component<ExpressionProps> {
    static propTypes: {
        filter: default_2.Validator<object>;
        fields: default_2.Validator<any[]>;
        ariaLabel: default_2.Requireable<string>;
        onChange: default_2.Validator<(...args: any[]) => any>;
        onRemove: default_2.Validator<(...args: any[]) => any>;
    };
    render(): JSX.Element;
    private onFieldChange;
    private onOperatorChange;
    private onInputChange;
    private triggerOnFilterChange;
    private onFilterRemove;
}

/**
 * @hidden
 */
export declare interface ExpressionChangeEvent extends BaseEvent<Expression> {
    prevFilter: FilterDescriptor;
    nextFilter: FilterDescriptor;
}

/**
 * @hidden
 */
export declare interface ExpressionProps {
    filter: FilterDescriptor;
    fields: Array<FieldSettings>;
    ariaLabel?: string;
    onChange: (event: ExpressionChangeEvent) => void;
    onRemove: (event: ExpressionRemoveEvent) => void;
}

/**
 * @hidden
 */
export declare interface ExpressionRemoveEvent extends BaseEvent<Expression> {
    filter: FilterDescriptor;
}

/**
 * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.
 *
 * @param {object} item - The source data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {object} propsToExtend - The props with which the source data item will be extended.
 * @returns {object} - The target data item.
 */
export declare const extendDataItem: (item: any, subItemsField: string, propsToExtend?: any) => any;

/**
 * @hidden
 */
export declare interface ExtendedColumnProps<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends TreeColumnBaseProps<C, H, F> {
    declarationIndex: number;
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    index: number;
    children: ExtendedColumnProps<C, H, F>[];
    left: number;
    right: number;
    rightBorder: boolean;
    groupable: boolean;
    ariaColumnIndex: number;
    isAccessible: boolean;
}

/**
 * The FieldSettings object.
 */
export declare interface FieldSettings {
    /**
     * The field name.
     */
    name: string;
    /**
     * The field label, which will be shown in the fields DropDownList.
     */
    label: string;
    /**
     * The filter editor component. Could be any of the built-in TextFilter, NumericFilter, DateFilter, BooleanFilter or a custom component.
     */
    filter: any;
    /**
     * The collection of operators which will be passed to the operators DropDownList.
     */
    operators: Array<FilterOperator>;
    /**
     * Specifies the smallest value that can be entered.
     */
    min?: number;
    /**
     * Specifies the greatest value that can be entered.
     */
    max?: number;
}

/**
 * Represents the [KendoReact Filter component]({% slug overview_filter %}).
 */
export declare class Filter extends React_2.Component<FilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        className: default_2.Requireable<string>;
        style: default_2.Requireable<object>;
        fields: (props: FilterProps, propName: string) => Error | null;
        ariaLabelGroup: default_2.Requireable<string>;
        ariaLabelExpression: default_2.Requireable<string>;
        value: default_2.Validator<object>;
        onChange: default_2.Validator<(...args: any[]) => any>;
    };
    /**
     * @hidden
     */
    wrapperRef: React_2.RefObject<HTMLDivElement | null>;
    private navigation?;
    private readonly showLicenseWatermark;
    private readonly licenseMessage?;
    constructor(props: FilterProps);
    /**
     * @hidden
     */
    componentDidMount(): void;
    /**
     * @hidden
     */
    render(): JSX.Element;
    private onFilterChange;
    private onGroupRemove;
    private onKeyDown;
}

/**
 * @hidden
 */
export declare const FILTER_ROW_CLASS = "k-table-row k-filter-row";

/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
export declare function filterBy(data: any[], descriptors: FilterDescriptor[] | CompositeFilterDescriptor[], subItemsField: string): any[];

/**
 * @hidden
 */
export declare interface FilterCellProps {
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The function that will be called if the cell needs to notify its parent TreeList about a change.
     */
    onFilterChange?: (event: {
        filter: Array<FilterDescriptor>;
        field: string;
        syntheticEvent: React.SyntheticEvent<any>;
    }) => void;
    /**
     * The collection of `FilterDescriptor` objects that is passed by the TreeList component.
     */
    filter?: FilterDescriptor[];
    /**
     * @hidden
     */
    components?: {
        DatePicker?: any;
        DropDownList?: any;
        Input?: any;
        NumericTextBox?: any;
    };
    /**
     * @hidden
     */
    clearButtonTitle?: string;
}

/**
 * The FilterChangeEvent object.
 */
export declare interface FilterChangeEvent extends BaseEvent<Filter> {
    /**
     * The changed composite filter descriptor.
     */
    filter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface FilterComponentProps extends FilterCellProps {
    /**
     * The list of the operators.
     */
    operators?: FilterOperator[];
    /**
     * The accessible label of the component.
     */
    ariaLabel?: string;
    /**
     * @ hidden
     */
    min?: number;
    /**
     * @hidden
     */
    max?: number;
}

/**
 * @hidden
 */
export declare interface FilterComponentSettings {
    inputComponent: (props: any) => React_2.ReactNode;
    operatorComponent: (props: any, cellProps: FilterComponentProps) => React_2.ReactNode;
    emptyFilter: FilterDescriptor;
    operators?: FilterOperator[];
}

/**
 * A filter operator object.
 */
export declare interface FilterOperator {
    /**
     * The label of the operator.
     */
    text: string;
    /**
     * The operator value.
     */
    operator: any;
}

/**
 * The props of the Filter component.
 */
export declare interface FilterProps {
    /**
     * Adds custom CSS classes to the Filter's root element.
     */
    className?: string;
    /**
     * Applies custom styles to the Filter's root element.
     */
    style?: React_2.CSSProperties;
    /**
     * Defines the field settings for the Filter. Each field represents a filterable column.
     *
     * @example
     * fields: [
     *   { name: "ProductName", label: "Product Name", type: "string" },
     *   { name: "Price", label: "Price", type: "number" }
     * ]
     */
    fields: Array<FieldSettings>;
    /**
     * Specifies the composite filter descriptor value.
     * This object defines the current state of the applied filters.
     *
     * @example
     * value: {
     *   logic: "and",
     *   filters: [
     *     { field: "ProductName", operator: "contains", value: "Chai" },
     *     { field: "Price", operator: "gte", value: 20 }
     *   ]
     * }
     */
    value: CompositeFilterDescriptor;
    /**
     * Provides an accessible label for the Filter's container component.
     * Similar to the [aria-label](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label) attribute.
     */
    ariaLabel?: string;
    /**
     * Provides an accessible label for the Filter's underlying Group component.
     */
    ariaLabelGroup?: string;
    /**
     * Provides an accessible label for the Filter's underlying Expression component.
     */
    ariaLabelExpression?: string;
    /**
     * The Filter onChange event.
     *
     * @param event - The event object containing the updated filter descriptor.
     */
    onChange: (event: FilterChangeEvent) => void;
    /**
     * Specifies the initial composite filter descriptor used when a new group is created.
     *
     * @example
     * defaultGroupFilter: {
     *   logic: "and",
     *   filters: []
     * }
     */
    defaultGroupFilter?: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare const FilterRow: (props: FilterRowProps) => JSX.Element;

/**
 * @hidden
 */
export declare interface FilterRowProps {
    columns: ExtendedColumnProps[];
    filter?: FilterDescriptor[];
    filterChange: (event: {
        filter: FilterDescriptor[];
        field: string;
        syntheticEvent: React_2.SyntheticEvent<any>;
    }) => void;
    sort?: SortDescriptor[];
    ariaRowIndex?: number;
}

/** @hidden */
export declare const findGroupExpand: (groupExpand: GroupExpandDescriptor[], group: GroupState) => GroupExpandDescriptor | undefined;

/**
 * @hidden
 */
export declare function flatData(data: any[], getChildren: (dataItem: any) => any[], itemMap: (item: any) => any): DataItemWrapper[];

/** @hidden */
export declare const flatToTree: (flat: GroupState[]) => GroupExpandDescriptor[];

/**
 * @hidden
 */
export declare const getClipboardData: (event: ClipboardDataEvent, copiedItems: ClipboardItem_2[]) => string;

/**
 * @hidden
 */
export declare const getClipboardItemsToPaste: (args: PopulateClipboardArgs, clipboardText: string) => string[][];

/**
 * @hidden
 */
export declare const getClipboardText: (copiedItems: ClipboardItem_2[], event: ClipboardDataEvent) => string;

/** @hidden */
export declare const getColumnIndex: (element: HTMLTableCellElement) => number | undefined;

/** @hidden */
export declare const getDetailExpandableOptions: (expandable?: boolean | TableExpandableSettings) => TableExpandableSettings;

/**
 * @hidden
 */
export declare const getEditableOptions: (editable?: boolean | TableEditableSettings) => Required<TableEditableSettings>;

/** @hidden */
export declare const getGroupExpandableOptions: (groupExpandable?: boolean | TableGroupExpandableSettings) => TableGroupExpandableSettings;

/**
 * Get all group ids from the data.
 *
 * @param {{data: any[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const getGroupIds: (options: {
    data: any;
}) => string[];

/**
 * @hidden
 */
export declare function getIndex(event: any, parent: HTMLTableRowElement | HTMLDivElement | null): number;

/**
 * Returns the data item path in the tree based on the level parameter.
 *
 * @param {any[]} tree - The data tree.
 * @param {number[]} level - The level of the target tree item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The path of the data item.
 */
export declare const getItemPath: (tree: any[], level: number[], subItemsField?: string) => any[];

/**
 * @hidden
 */
export declare const getItemsToPaste: (args: PopulateClipboardArgs, clipboardText: string) => any[][];

/**
 * @hidden
 */
export declare const getItemsToUpdateOnPaste: (args: PopulateClipboardArgs, selectedItems: ClipboardItem_2[], dataLength: number, dataItemKey: string) => any[];

/** @hidden */
export declare const getOffset: (offsetParent: any) => any;

/**
 * @hidden
 */
export declare const getPastedItems: (args: PopulateClipboardArgs, clipboardText: string) => ClipboardItem_2[];

/**
 * @hidden
 */
export declare const getPreviouslyCopiedItemsData: (previousCopiedItems?: ClipboardItem_2[]) => any[][];

/** @hidden */
export declare const getRowIndex: (element: HTMLTableRowElement) => number | undefined;

/** @hidden */
export declare const getSearchFromString: (search: CompositeFilterDescriptor, value: string) => CompositeFilterDescriptor;

/**
 * @hidden
 */
export declare const getSelectedItems: (args: PopulateClipboardArgs) => ClipboardItem_2[];

/**
 * Get selected state from the component selection event.
 *
 * @param {{event: TableSelectionChangeEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedState: (options: {
    event: TableSelectionChangeEvent<any>;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/**
 * Get selected state from the component KeyDown event.
 *
 * @param {{event: TableKeyDownEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedStateFromKeyDown: (options: {
    event: TableKeyDownEvent<any>;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/** @hidden */
export declare const getSelectionOptions: (selectable?: boolean | TableSelectableSettings) => Required<TableSelectableSettings>;

/** @hidden */
export declare const getStringFromSearch: (search: CompositeFilterDescriptor | undefined) => string;

/**
 * Represents the object of the `GridClipboardEvent` event.
 */
export declare interface GridClipboardEvent extends ClipboardDataEvent, ClipboardData {
}

/**
 * @hidden
 */
export declare class Group extends React_2.Component<GroupProps> {
    static propTypes: {
        filter: default_2.Validator<object>;
        fields: default_2.Validator<any[]>;
        ariaLabel: default_2.Requireable<string>;
        ariaLabelExpression: default_2.Requireable<string>;
        onChange: default_2.Validator<(...args: any[]) => any>;
        onRemove: default_2.Validator<(...args: any[]) => any>;
        defaultGroupFilter: default_2.Validator<object>;
    };
    render(): JSX.Element;
    private onGroupRemove;
    private onAddExpression;
    private onAddGroup;
    private onLogicAnd;
    private onLogicOr;
    private changeLogic;
    private replaceFilter;
    private onChange;
    private onRemove;
}

/** @hidden */
export declare enum GROUP_EXPAND_ACTION {
    TOGGLE = "GROUP-EXPAND_TOGGLE",
    EXPAND = "GROUP-EXPAND_EXPAND",
    COLLAPSE = "GROUP-EXPAND_COLLAPSE",
    RESET = "GROUP-EXPAND_RESET"
}

/**
 * @hidden
 */
export declare interface GroupChangeEvent extends BaseEvent<Group> {
    prevFilter: CompositeFilterDescriptor;
    nextFilter: CompositeFilterDescriptor;
}

/** @hidden */
export declare type GroupExpandAction = {
    type: GROUP_EXPAND_ACTION;
    group: GroupState;
};

/**
 * The descriptor used to define the expanded state of a group.
 */
export declare type GroupExpandDescriptor = {
    value: any;
    field: string;
    expanded?: boolean;
    groups?: GroupExpandDescriptor[];
};

/** @hidden */
export declare const groupExpandReducer: (state: GroupExpandDescriptor[], action: GroupExpandAction, options?: TableGroupExpandableSettings) => GroupExpandDescriptor[];

/**
 * @hidden
 */
export declare interface GroupProps {
    filter: CompositeFilterDescriptor;
    fields: Array<FieldSettings>;
    ariaLabel?: string;
    ariaLabelExpression?: string;
    onChange: (event: GroupChangeEvent) => void;
    onRemove: (event: GroupRemoveEvent) => void;
    defaultGroupFilter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface GroupRemoveEvent extends BaseEvent<Group> {
    filter: CompositeFilterDescriptor;
}

/** @hidden */
export declare type GroupState = {
    value: any;
    field: string;
    expanded?: boolean;
    parents?: GroupState[];
};

/**
 * @hidden
 */
declare type handler = (prevIndex: number, nextIndex: number, nativeEvent: any) => void;

/**
 * @hidden
 */
export declare class Header extends React_2.Component<HeaderProps> {
    private element;
    componentDidMount(): void;
    render(): JSX.Element;
}

/**
 * @hidden
 */
export declare function HeaderCell(props: HeaderCellProps): JSX.Element;

/**
 * @hidden
 */
export declare interface HeaderCellBaseProps {
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The title of the column in which the cell is located.
     */
    title?: string;
    /**
     * The `click` event handler of the cell.
     */
    onClick?: any;
    /**
     * The `selectionChange` event handler of the cell.
     */
    selectionChange: any;
    /**
     * The `selectionValue` event handler of the column in which the cell is located.
     */
    selectionValue: any;
    /**
     * A function for overriding the default rendering of the header cell.
     */
    render?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellBaseProps) => React_2.ReactNode;
    /**
     * The current sort icons.
     */
    children: React_2.ReactNode;
}

/**
 * @hidden
 */
export declare interface HeaderCellProps extends HeaderCellBaseProps {
    /**
     * A function for overriding the default rendering of the header cell.
     */
    render?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellProps) => React_2.ReactNode;
}

/**
 * @hidden
 */
export declare interface HeaderProps {
    headerRow: React_2.ReactElement<any>;
    filterRow?: React_2.ReactElement<any>;
    columnResize?: ColumnResize;
    reorderable?: boolean;
}

/**
 * @hidden
 */
export declare class HeaderRow<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends React_2.Component<HeaderRowProps<C, H, F>, {}> {
    cellClick: (e: React_2.MouseEvent<HTMLSpanElement> | React_2.KeyboardEvent<HTMLElement>, column: TreeColumnBaseProps<C, H, F>) => void;
    cellKeyDown: (event: React_2.KeyboardEvent<HTMLElement>, column: TreeColumnBaseProps<C, H, F>) => void;
    sortIcon(sortIndex: number): (false | JSX.Element)[] | null;
    render(): JSX.Element[];
    private cells;
}

/**
 * @hidden
 */
export declare interface HeaderRowProps<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends ColumnDraggableProps {
    sortable?: SortSettings;
    sortChange?: (e: React_2.SyntheticEvent<any>, descriptors: SortDescriptor[], field?: string) => void;
    filterChange?: (e: React_2.SyntheticEvent<any>, descriptors: FilterDescriptor[], field?: string) => void;
    sort?: SortDescriptor[];
    columns: ExtendedColumnProps<C, H, F>[];
    columnsMap: number[][];
    selectionChange: (e: any) => void;
    cellRender?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellProps) => React_2.ReactNode;
    columnResize?: ColumnResize<C, H, F>;
    columnMenu?: React_2.ComponentType<ColumnMenuProps>;
    columnMenuFilter?: CompositeFilterDescriptor[];
    columnMenuFilterChange?: (e: React_2.SyntheticEvent<any>, filter: CompositeFilterDescriptor[], field?: string) => void;
}

/**
 * @hidden
 */
export declare function HeaderSelectionCell(props: HeaderSelectionCellProps): JSX.Element;

/**
 * @hidden
 */
export declare interface HeaderSelectionCellProps extends HeaderCellProps {
    inputId: string;
}

export declare const HeaderTdElement: {
    (props: HeaderTdElementProps): JSX.Element;
    displayName: string;
};

export declare interface HeaderTdElementProps extends React_2.TdHTMLAttributes<HTMLTableCellElement> {
    /** ARIA sort state indicating column sorting direction */
    ariaSort?: 'none' | 'ascending' | 'descending';
    /** ARIA label for accessibility */
    ariaLabel?: string;
    /** ARIA column index for screen readers */
    ariaColumnIndex?: number;
    /** ARIA selected state for the header cell */
    ariaSelected?: boolean;
    /** ARIA description for additional context */
    ariaDescription?: string;
    /** Number of columns the cell spans */
    colSpan?: number;
    /** Number of rows the cell spans */
    rowSpan?: number;
    /** ARIA role for the element */
    role?: string;
    /** Unique identifier for the column */
    columnId: string;
    /** CSS class names for styling */
    className?: string;
    /** Inline styles for the element */
    style?: any;
    /** Child elements to render inside the header cell */
    children?: any;
    /** Keyboard event handler */
    onKeyDown?: any;
    /** Whether the cell supports keyboard navigation */
    navigatable?: boolean;
}

export declare const HeaderThElement: {
    (props: HeaderThElementProps): JSX.Element;
    displayName: string;
};

export declare interface HeaderThElementProps extends React_2.ThHTMLAttributes<HTMLTableCellElement> {
    /** ARIA sort state indicating column sorting direction */
    ariaSort?: 'none' | 'ascending' | 'descending';
    /** ARIA label for accessibility */
    ariaLabel?: string;
    /** ARIA column index for screen readers */
    ariaColumnIndex?: number;
    /** ARIA selected state for the header cell */
    ariaSelected?: boolean;
    /** ARIA description for additional context */
    ariaDescription?: string;
    /** Number of columns the cell spans */
    colSpan?: number;
    /** Number of rows the cell spans */
    rowSpan?: number;
    /** ARIA role for the element */
    role?: string;
    /** Unique identifier for the column */
    columnId: string;
    /** CSS class names for styling */
    className?: string;
    /** Inline styles for the element */
    style?: any;
    /** Child elements to render inside the header cell */
    children?: any;
    /** Keyboard event handler */
    onKeyDown?: any;
    /** Whether the cell supports keyboard navigation */
    navigatable?: boolean;
}

/** @hidden */
export declare const isExpanded: (groupExpand: GroupExpandDescriptor[], group: GroupState) => boolean;

/** @hidden */
export declare const isInNonSelectable: (target: HTMLElement | null) => boolean;

/**
 * @hidden
 */
export declare function isRtl(element: HTMLElement | null): boolean;

/**
 * @hidden
 */
export declare const itemToString: (item: any, cols: string[]) => string | null;

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_CANCEL_BUTTON_CLASS = "k-grid-cancel-command";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_BODY = "data-keyboardnavbody";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_HEADER = "data-keyboardnavheader";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ID = "data-keyboardnavid";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_LEVEL = "data-keyboardnavlevel";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_SCOPE = "data-keyboardnavscope";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ZONE = "data-keyboardnavzone";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_EDIT_BUTTON_CLASS = "k-grid-edit-command";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_FILTER_COL_SUFFIX = "_filter";

/**
 * @hidden
 */
export declare function mapColumns(columns: Array<{
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, changedColumnLength?: boolean): number[][];

/**
 * Changes the `subItems` collection of each data item which matches the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item and
 * will return `true` for items that have to change the subitems collection.
 * @param {(subItems: object[]) => object[]} change - A function which
 * has as a parameter the subitems collection of the matched items and which will return the new subitems collection.
 * @returns {any[]} - The new data tree.
 */
export declare const modifySubItems: (data: any[], subItemsField: string, condition: (item: any) => boolean, change: (subItems: any[]) => any[]) => any[];

/**
 * Moves the targeted item in the tree to another position.
 *
 * @param {any[]} data - The data tree.
 * @param {number[]} target - The level of the target tree item which will be moved.
 * @param {number[] | null} destination - The level of the destination tree item where the target item will be moved in.
 * If it is null, the target item will be added at the root level.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The new data tree.
 */
export declare const moveTreeItem: (data: any[], target: number[], destination: number[] | null, subItemsField: string) => any[];

/**
 * The navigatable modes
 */
export declare enum NavigatableMode {
    incell = "incell",
    inline = "inline"
}

/**
 * The navigatable additional settings
 */
export declare interface NavigatableSettings {
    /**
     * The available values are:
     * * `incell`
     * * `inline`
     */
    mode?: NavigatableMode;
}

/**
 * @hidden
 */
export declare function nextColumn(columns: {
    depth: number;
    locked?: boolean;
}[], current: number): {
    depth: number;
    locked?: boolean | undefined;
} | null;

/**
 * @hidden
 */
export declare const normalize: (...settings: (SortSettings | ColumnSortSettings)[]) => any;

/**
 * The NumericFilter component used for editing numeric value of FilterDescriptor object.
 */
export declare class NumericFilter extends React_2.Component<NumericFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: default_2.Validator<object>;
        onFilterChange: default_2.Validator<(...args: any[]) => any>;
    };
    /**
     * @hidden
     */
    render(): JSX.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class NumericFilterCell extends NumericFilterCell_base {
}

declare const NumericFilterCell_base: React_2.ComponentClass<FilterComponentProps_2, any>;

/**
 * The props of the NumericFilter component.
 */
export declare interface NumericFilterProps extends TextFilterProps {
    /**
     * Specifies the smallest value that can be entered.
     */
    min?: number;
    /**
     * Specifies the greatest value that can be entered.
     */
    max?: number;
}

/**
 * Represents the operators for the TextFilter, NumericFilter, DateFilter and BooleanFilter components.
 *
 * The text field of each operator object will be resolved according to the
 * [localization messages]({% slug globalization_datatools %}#toc-messages).
 */
export declare class Operators {
    /**
     * An array containing the operators for the TextFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.containsOperator', operator: 'contains' }
     * - { text: 'filter.notContainsOperator', operator: 'doesnotcontain' }
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.startsWithOperator', operator: 'startswith' }
     * - { text: 'filter.endsWithOperator', operator: 'endswith' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     * - { text: 'filter.isEmptyOperator', operator: 'isempty' }
     * - { text: 'filter.isNotEmptyOperator', operator: 'isnotempty' }
     */
    static get text(): FilterOperator[];
    /**
     * An array containing the operators for the NumericFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.gteOperator', operator: 'gte' }
     * - { text: 'filter.gtOperator', operator: 'gt' }
     * - { text: 'filter.lteOperator', operator: 'lte' }
     * - { text: 'filter.ltOperator', operator: 'lt' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get numeric(): FilterOperator[];
    /**
     * An array containing the operators for the DateFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.afterOrEqualOperator', operator: 'gte' }
     * - { text: 'filter.afterOperator', operator: 'gt' }
     * - { text: 'filter.beforeOperator', operator: 'lt' }
     * - { text: 'filter.beforeOrEqualOperator', operator: 'lte' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get date(): FilterOperator[];
    /**
     * An array containing the operators for the BooleanFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     */
    static get boolean(): FilterOperator[];
}

/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
export declare function orderBy(data: any[], descriptors: SortDescriptor[], subItemsField: string): any[];

/**
 * Represents the object of the `onPageChange` event.
 */
export declare interface PageChangeEvent extends BasePageChangeEvent {
    /**
     * An event target.
     */
    target: PagerHandle;
    /**
     * A React Synthetic Event.
     */
    syntheticEvent: React.SyntheticEvent<any>;
    /**
     * A native DOM event.
     */
    nativeEvent: any;
    /**
     * A target change event.
     */
    targetEvent: PagerTargetEvent;
}

export declare const Pager: React_2.ForwardRefExoticComponent<PagerProps & React_2.RefAttributes<PagerHandle>>;

export declare interface PagerHandle {
    /**
     * Represents the element of the Pager component.
     */
    element: HTMLDivElement | null;
    /**
     * Represents the props of the Pager component.
     */
    props: Readonly<PagerProps>;
}

export declare interface PagerProps {
    /**
     * The total number of records.
     */
    total: number;
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
    /**
     * Sets additional classes to the Pager.
     */
    className?: string;
    /**
     * The styles that are applied to the Pager.
     */
    style?: React.CSSProperties;
    /**
     * Sets the maximum numeric buttons count before the buttons are collapsed.
     */
    buttonCount?: number;
    /**
     * Toggles the information about the current page and the total number of records.
     */
    info?: boolean;
    /**
     * Defines the type of the pager.
     * * (Default) `numeric` â Renders buttons with numbers.
     * * `input` â Renders an input field for typing the page number.
     */
    type?: 'numeric' | 'input';
    /**
     * Displays a menu for selecting the page size.
     */
    pageSizes?: Array<number> | Array<number | string>;
    /**
     * Sets the selected value of the page size Dropdownlist.
     * It is useful when the selected value could also be a string not only a number.
     */
    pageSizeValue?: string | number;
    /**
     * Toggles the **Previous** and **Next** buttons.
     */
    previousNext?: boolean;
    /**
     * Defines if the pager will be responsive.
     * If true, hides the tools that do not fit to the available space.
     *
     * @default `true`
     */
    responsive?: boolean;
    /**
     * Configures the `size` of the Pager.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `className`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large';
    /**
     * Fires when the page of the Pager is changed. You have to handle the event yourself and page the data.
     */
    onPageChange?: ((event: PageChangeEvent) => void) | ((event: BasePageChangeEvent) => void);
    /**
     * Useful for modifying the Pager messages.
     */
    messagesMap?: (messageKey: string) => {
        messageKey: string;
        defaultMessage: string;
    };
    /**
     * Sets the direction of the component.
     */
    dir?: string;
    /**
     * If set to `true`, the user can use dedicated shortcuts to interact with the Pager.
     * By default, navigation is disabled and the Pager content is accessible in the normal tab sequence.
     */
    navigatable?: boolean;
    /**
     * Controls the disabled state of the Pager. Defaults to `false`.
     */
    disabled?: boolean;
    /**
     * Providing different rendering of the page sizes select element based on the screen dimensions.
     */
    adaptive?: boolean;
    /**
     * Specifies the text that is rendered as title in the adaptive page sizes select element.
     */
    adaptiveTitle?: string;
}

/**
 * A Pager target event.
 */
export declare interface PagerTargetEvent {
    [key: string]: any;
    /**
     * An event target.
     */
    target?: any;
    /**
     * An event value.
     */
    value?: any;
}

/**
 * Represents the `PopulateClipboardArgs` event argument.
 */
export declare interface PopulateClipboardArgs {
    /**
     * Represents the base object of the `ClipboardDataEvent` event.
     */
    event: ClipboardDataEvent;
    /**
     * Represents the current selected state of the data.
     */
    selectedState: SelectDescriptor;
    /**
     * Passes the data currently displayed.
     */
    data: any[];
    /**
     * Passes dataItemKey name of the field that could be used to make difference between dataItems.
     */
    dataItemKey?: string;
    /**
     * Passes subItemsField that will be used in grouping cases.
     */
    subItemsField?: string;
    /**
     * Previous copied items.
     */
    previousCopiedItems?: ClipboardItem_2[];
}

/**
 * A function used to populate the Clipboard data.
 */
export declare const populateClipboardData: (args: PopulateClipboardArgs) => ClipboardData;

/**
 * @hidden
 */
export declare function readColumns<C = CellProps, H = HeaderCellProps, F = FilterCellProps>(elements: TreeColumnBaseProps<C, H, F>[], idInfo: {
    prevId: number;
    idPrefix: string;
}, depth?: number): ExtendedColumnProps<C, H, F>[];

/** @hidden */
export declare const relativeContextElement: (element: any) => any;

/**
 * Represents a remote data source with CRUD operations (Create, Read, Update, Delete).
 *
 * @template T - The type of data items in the data source. Defaults to any.
 */
export declare type RemoteDataSource<T extends object = any> = DataSource<T> & {
    /** Set of original data items read from the remote source, indexed by ID */
    reads: Map<string | number | symbol | null, T>;
    /** Map of created items that need to be synced */
    creates: Map<string | number | symbol | null, T>;
    /** Map of updated items that need to be synced */
    updates: Map<string | number | symbol | null, T>;
    /** Map of items marked for deletion that need to be synced */
    deletes: Map<string | number | symbol | null, T>;
    /** Map of dirty fields for each item */
    dirty: Map<string | number | symbol | null, Set<string>>;
    /** Map of errors for each item */
    errors: Map<string | number | symbol | null, any[]>;
    /** Adds an error to an item */
    addError: (params: {
        error: any;
        data?: T;
    }) => void;
    /** Removes an error from an item */
    removeError: (params: {
        error: any;
    }) => void;
    /** Removes all errors for an item */
    removeErrors: (params: {
        data: T;
    }) => void;
    /** Removes all errors */
    removeAllErrors: () => void;
    /** Reads data from the remote source */
    read: (state?: State) => Promise<T[]>;
    /** Creates a new item */
    create: (params: {
        data: T;
    }) => void;
    /** Updates an existing item */
    update: (params: {
        data: T;
        field?: string;
    }) => void;
    /** Deletes an item */
    delete: (params: {
        data: T;
    }) => void;
    /** Syncs all pending changes with the remote source */
    sync: () => Promise<void>;
    /** Syncs a single item with the remote source */
    syncItem: (params: {
        data: T;
    }) => Promise<void>;
    /** Removes an item from creates */
    removeCreate: (params: {
        data: T;
    }) => void;
    /** Removes an item from updates */
    removeUpdate: (params: {
        data: T;
    }) => void;
    /** Removes an item from deletes */
    removeDelete: (params: {
        data: T;
    }) => void;
    /** Adds an item to reads */
    pushCreate: (params: {
        data: T;
    }) => void;
    /** Updates an item in reads */
    pushUpdate: (params: {
        data: T;
    }) => void;
    /** Removes an item from reads */
    pushDelete: (params: {
        data: T;
    }) => void;
    /** Discards all pending changes */
    discard: () => void;
};

/**
 * Configuration properties for the remote data source.
 * Extends the basic DataSourceProps with remote data operations capabilities.
 *
 * @template T - The type of data items in the data source. Defaults to any object.
 */
export declare interface RemoteDataSourceProps<T extends object = any> extends DataSourceProps<T> {
    /**
     * Map of original data items read from the remote source, indexed by ID.
     */
    reads?: Map<string | number | symbol | null, T>;
    /**
     * Map of created items that need to be synced with the remote source.
     */
    creates?: Map<string | number | symbol | null, T>;
    /**
     * Map of updated items that need to be synced with the remote source.
     */
    updates?: Map<string | number | symbol | null, T>;
    /**
     * Map of items marked for deletion that need to be synced with the remote source.
     */
    deletes?: Map<string | number | symbol | null, T>;
    /**
     * Determines if filtering operations should be performed on the server.
     * When true, filter parameters are sent to the server during read operations.
     *
     * @default true
     */
    serverFiltering?: boolean;
    /**
     * Determines if sorting operations should be performed on the server.
     * When true, sort parameters are sent to the server during read operations.
     *
     * @default true
     */
    serverSorting?: boolean;
    /**
     * Determines if paging operations should be performed on the server.
     * When true, skip and take parameters are sent to the server during read operations.
     *
     * @default true
     */
    serverPaging?: boolean;
    /**
     * Determines if grouping operations should be performed on the server.
     * When true, group parameters are sent to the server during read operations.
     *
     * @default true
     */
    serverGrouping?: boolean;
    /**
     * Configuration for CRUD operations transport.
     * Defines how data is sent to and received from the server.
     */
    transport?: {
        /**
         * Configuration for create operations.
         * Can be either an object specifying the endpoint configuration or a function for custom implementation.
         */
        create?: {
            /**
             * URL for the create operation. Can be a string or a function that returns a string based on the data item.
             */
            url: string | ((dataItem: T) => string);
            /**
             * HTTP method to use for the create operation.
             *
             * @default "POST"
             */
            method?: string;
            /**
             * Content-Type header to use for the request.
             *
             * @default "application/json"
             */
            contentType?: string;
            /**
             * Additional data to include in the request.
             */
            data?: {
                [key: string]: any;
            };
            /**
             * Function that transforms the request data before sending it to the server.
             *
             * @param data - The data item to transform
             * @returns Transformed data
             */
            parameterMap?: (data: T) => any;
            /**
             * Callback executed when the create operation is successful.
             *
             * @param data - The created data item
             */
            onSuccess?: (data: T) => void;
            /**
             * Function to process the server response.
             *
             * @param response - The server response
             * @returns Processed data item or null
             */
            onResponse?: (response: any) => T | null;
            /**
             * Callback executed when the create operation fails.
             *
             * @param error - The error from the server
             */
            onError?: (error: any) => void;
        } | ((options: {
            data: T;
        }) => Promise<T>);
        /**
         * Configuration for read operations.
         * Can be either an object specifying the endpoint configuration or a function for custom implementation.
         */
        read?: {
            /**
             * URL for the read operation. Can be a string or a function that returns a string.
             */
            url: string | (() => string);
            /**
             * HTTP method to use for the read operation.
             *
             * @default "GET"
             */
            method?: string;
            /**
             * Content-Type header to use for the request.
             */
            contentType?: string;
            /**
             * Additional data to include in the request.
             */
            data?: {
                [key: string]: any;
            };
            /**
             * Function that transforms the request data before sending it to the server.
             *
             * @param data - The request parameters including filter, paging, sorting, and grouping info
             * @returns Transformed request parameters
             */
            parameterMap?: (data: {
                filter?: CompositeFilterDescriptor;
                skip?: number;
                take?: number;
                sort?: SortDescriptor[];
                group?: GroupDescriptor[];
            }) => any;
            /**
             * Callback executed when the read operation is successful.
             *
             * @param data - The retrieved data items
             */
            onSuccess?: (data: T[]) => void;
            /**
             * Function to process the server response.
             *
             * @param response - The server response
             * @returns Processed data item or null
             */
            onResponse?: (response: any) => T | null;
            /**
             * Callback executed when the read operation fails.
             *
             * @param error - The error from the server
             */
            onError?: (error: any) => void;
        } | ((options: {
            filter?: CompositeFilterDescriptor;
            skip?: number;
            take?: number;
            sort?: SortDescriptor[];
            group?: GroupDescriptor[];
            onSuccess?: (data: T[]) => void;
            onResponse?: (response: any) => T | null;
            onError?: (error: any) => void;
        }) => Promise<T[]>);
        /**
         * Configuration for update operations.
         * Can be either an object specifying the endpoint configuration or a function for custom implementation.
         */
        update?: {
            /**
             * URL for the update operation. Can be a string or a function that returns a string based on the data item.
             */
            url: string | ((dataItem: T) => string);
            /**
             * HTTP method to use for the update operation.
             *
             * @default "PUT"
             */
            method?: string;
            /**
             * Content-Type header to use for the request.
             *
             * @default "application/json"
             */
            contentType?: string;
            /**
             * Additional data to include in the request.
             */
            data?: {
                [key: string]: any;
            };
            /**
             * Function that transforms the request data before sending it to the server.
             *
             * @param data - The data item to transform
             * @returns Transformed data
             */
            parameterMap?: (data: T) => any;
            /**
             * Callback executed when the update operation is successful.
             *
             * @param data - The updated data item
             */
            onSuccess?: (data: T) => void;
            /**
             * Function to process the server response.
             *
             * @param response - The server response
             * @returns Processed data item or null
             */
            onResponse?: (response: any) => T | null;
            /**
             * Callback executed when the update operation fails.
             *
             * @param error - The error from the server
             */
            onError?: (error: any) => void;
        } | ((options: {
            data: T;
        }) => Promise<T>);
        /**
         * Configuration for delete operations.
         * Can be either an object specifying the endpoint configuration or a function for custom implementation.
         */
        delete?: {
            /**
             * URL for the delete operation. Can be a string or a function that returns a string based on the data item.
             */
            url: string | ((dataItem: T) => string);
            /**
             * HTTP method to use for the delete operation.
             *
             * @default "DELETE"
             */
            method?: string;
            /**
             * Content-Type header to use for the request.
             */
            contentType?: string;
            /**
             * Additional data to include in the request.
             */
            data?: {
                [key: string]: any;
            };
            /**
             * Function that transforms the request data before sending it to the server.
             *
             * @param data - The data item to transform
             * @returns Transformed data
             */
            parameterMap?: (data: T) => any;
            /**
             * Callback executed when the delete operation is successful.
             *
             * @param data - The deleted data item
             */
            onSuccess?: (data: T) => void;
            /**
             * Function to process the server response.
             *
             * @param response - The server response
             * @returns Processed data item or null
             */
            onResponse?: (response: any) => T | null;
            /**
             * Callback executed when the delete operation fails.
             *
             * @param error - The error from the server
             */
            onError?: (error: any) => void;
        } | ((options: {
            data: T;
        }) => Promise<T>);
    };
    /**
     * Schema configuration for parsing and mapping server responses.
     * Extends the base DataSourceProps schema with additional properties for remote data.
     */
    schema: DataSourceProps['schema'] & {
        /**
         * Specifies the field in the response that contains the data items,
         * or a function that extracts the data items from the response.
         */
        data?: string | ((data: any) => T[]);
        /**
         * Specifies the field in the response that contains the total count,
         * or a function that extracts the total count from the response.
         */
        total?: string | ((data: any) => number);
        /**
         * Specifies the field in the response that contains error information,
         * or a function that extracts error information from the response.
         */
        errors?: string | ((data: any) => any);
    };
}

/**
 * Removes the items from the passed `data` which match the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item
 * in the tree data and the items for which returns true will be removed.
 * @returns {any[]} - The new data tree.
 */
export declare const removeItems: (data: any[], subItemsField: string, condition: (item: any) => boolean) => any[];

/**
 * Represents the SearchField that configures the way a data field is searched.
 */
export declare interface SearchField {
    /**
     * The name of the searched field.
     */
    field: string;
    /**
     * The string operator that will be used for search.
     */
    operator?: string;
    /**
     * Defines if the search is case sensitive.
     */
    ignoreCase?: boolean;
}

/**
 * The descriptor used to define the selected state of a data-item.
 */
export declare type SelectDescriptor = {
    [id: string]: boolean | number[];
};

/**
 * @hidden
 */
export declare const selectors: any;

/**
 * Apply the `expanded` prop to the group items in data based on the provided collection of group ids.
 *
 * @param {{data: any[], collapsedIds: string[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const setExpandedState: (options: {
    data: any;
    collapsedIds: string[];
}) => any[];

/**
 * Add unique ids to the group items inside data.
 *
 * @param {{data: any[], group: GroupDescriptor[]}} options - The options to be processed.
 */
export declare const setGroupIds: (options: {
    data: any;
    group?: Array<GroupDescriptor>;
}) => void;

/**
 * @hidden
 *
 * Apply the selected field to the data items based on the selected state.
 *
 * @param {{data: any, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string; selectedField: string; subItemsField?: string; }} options
 * @returns {any[]}
 */
export declare const setSelectedState: (options: {
    data: any;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
    selectedField: string;
    subItemsField?: string | undefined;
}) => any[];

/**
 * The settings for sorting the component data.
 */
export declare type SortSettings = boolean | (ColumnSortSettings & {
    /**
     * The sort mode of the component.
     *
     * The available modes are:
     * - `single`
     * - `multiple`
     */
    mode?: 'single' | 'multiple';
});

/**
 * @hidden
 */
export declare const stringOperator: (operator: any) => boolean;

/** @hidden */
export declare const TABLE_COL_INDEX_ATTRIBUTE = "data-grid-col-index";

/** @hidden */
export declare const TABLE_PREVENT_SELECTION_ELEMENT = "data-prevent-selection";

/** @hidden */
export declare const TABLE_ROW_INDEX_ATTRIBUTE = "data-grid-row-index";

/**
 * @hidden
 */
export declare function tableColumnsVirtualization(args: {
    enabled?: boolean;
    columns: {
        width?: string | number;
        locked?: boolean;
    }[];
    tableViewPortWidth: number;
    scrollLeft: number;
    getColSpan?: any;
    dataItem?: any;
}): {
    colSpans: number[];
    hiddenColumns: boolean[];
};

/** @hidden */
export declare interface TableDragSelectionReleaseEvent {
    /**
     * Selection start row index.
     */
    startRowIndex: number;
    /**
     * Selection start column index.
     */
    startColIndex: number;
    /**
     * Selection end row index.
     */
    endRowIndex: number;
    /**
     * Selection end column index.
     */
    endColIndex: number;
    /**
     * A native DOM event.
     */
    nativeEvent: any;
    /**
     * Is ctrl key modifier pressed.
     */
    ctrlKey: boolean;
    /**
     * Is alt key modifier pressed.
     */
    altKey: boolean;
    /**
     * Is meta key modifier pressed.
     */
    metaKey: boolean;
    /**
     * Is shift key modifier pressed.
     */
    shiftKey: boolean;
    /**
     * Selection mode.
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * Indicates if current event is created from drag.
     */
    isDrag: boolean;
}

export declare interface TableEditableSettings {
    /**
     * Determines if the editing is enabled.
     *
     * @default false
     */
    enabled?: boolean;
    /**
     * Determines the editing mode.
     * The available values are:
     * * `inline`
     * * `incell`
     *
     * @default 'incell
     */
    mode?: 'inline' | 'incell' | 'dialog';
}

/** @hidden */
export declare type TableExpandableSettings = {
    enabled?: boolean;
    column?: string;
};

/** @hidden */
export declare type TableGroupExpandableSettings = {
    enabled?: boolean;
    defaultExpand?: boolean;
};

/**
 * @hidden
 */
export declare const tableKeyboardNavigation: {
    onConstructor: (options: {
        navigatable?: boolean | undefined | NavigatableSettings;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        idPrefix?: string;
    }) => void;
    onComponentDidMount: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    onGetSnapshotBeforeUpdate: (options: {
        document?: Document;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    onComponentDidUpdate: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        focusFirst?: boolean;
        newEditableRow?: Element;
        singleEditRow?: boolean;
        lastActiveElement?: Element;
        navigatable?: boolean | NavigatableSettings;
    }) => void;
    onFocus: (event: React_2.FocusEvent<HTMLDivElement>, options: {
        navigatable?: boolean | NavigatableSettings;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
    }) => void;
    onKeyDown: (event: React_2.KeyboardEvent<HTMLElement>, options: {
        navigatable: boolean | NavigatableSettings;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        onNavigationAction?: ((options: {
            event: React_2.KeyboardEvent<HTMLElement>;
            focusElement: any;
            action?: "select" | "moveToNextPage" | "moveToPrevPage" | "reorderToLeft" | "reorderToRight" | undefined;
        }) => void) | undefined;
        columns?: object[] | undefined;
    }) => Promise<void>;
    generateMatrix: (options: {
        scope?: HTMLElement;
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    focusFirstDataElement: (options: {
        scope?: HTMLElement | undefined;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType | undefined;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType | undefined;
        };
    }, event?: any) => void;
};

/**
 * @hidden
 */
export declare const tableKeyboardNavigationBodyAttributes: {
    "data-keyboardnavbody": boolean;
};

/**
 * @hidden
 */
export declare const TableKeyboardNavigationContext: React_2.Context<TableKeyboardNavigationContextType | undefined>;

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationContextType {
    activeId: string | undefined;
    level: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationHeaderAttributes: {
    "data-keyboardnavheader": boolean;
};

/**
 * @hidden
 */
export declare const tableKeyboardNavigationScopeAttributes: {
    "data-keyboardnavscope": boolean;
};

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationStateType {
    activeElementIsFocused: boolean;
    prevNavigationIndexes?: [number, number];
    idPrefix: string;
    navigationMatrix: string[][];
    lastHeaderIndex: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationTools: {
    generateNavigatableId: (navigationId: string, idPrefix: string, type?: 'column' | 'cell' | 'group' | 'expand' | 'nodata') => string;
    getNavigatableId: (element: Element | null) => string | undefined;
    getNavigatableLevel: (element: Element | null) => number | undefined;
    getNavigatableElement: (scope: HTMLElement, options?: {
        level: number;
    }) => HTMLElement;
    getClosestNavigatableElement: (target: HTMLElement) => Element | null;
    getActiveNavDataElement: (scope: HTMLElement, activeId?: string) => HTMLElement;
    getClosestScope: (target: HTMLElement) => Element | null;
    getHeaderElement: (scope: HTMLElement) => Element | null;
    getBodyElement: (scope: HTMLElement) => Element | null;
    getFocusableElements: (scope: HTMLElement, options?: {
        focusable: boolean;
    }) => Element[];
    getNavigatableElements: (scope: HTMLElement | null, options?: {
        level: number;
    }) => any[];
    filterNavigatableElements: (options?: {
        level: number;
    }) => (element: HTMLElement) => boolean;
    focusElement: (options: {
        elementForFocus: HTMLElement;
        prevElement?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        event?: any;
    }) => void;
    getIdPrefix: (navigationStateRef: {
        current?: TableKeyboardNavigationStateType;
    }) => string;
    isNavigatable: (element: Element | null) => boolean;
    findNextIdByRowIndex: (initialRowIndex: number, cellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findNextIdByCellIndex: (rowIndex: number, initialCellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findId: (navigationMatrix: string[][], cellId?: string) => number[] | undefined;
    getNextNavigationIndex: (navigationStateRef: {
        current?: TableKeyboardNavigationStateType;
    }) => number;
    getFilterColumnId: (columnId: string) => string;
    focusFirstDataElement: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }, event?: any) => void;
    getClosestCancelButton: (target: HTMLElement) => Element | null | undefined;
    getClosestEditButton: (target: HTMLElement) => Promise<boolean | Element>;
    getRowAriaRowIndex: (target: HTMLElement) => undefined;
    getRemoveButtonByAriaRowIndex: (ariaRowIndex: number) => Element | null;
    getTableCellByKeyboardNavId: (navId: string) => Element | null;
    getParentCell: (target: HTMLElement) => Element | null;
    waitForElementToBeVisible: typeof waitForElementToBeVisible;
    getNextEditableCell: (currentIdIndexes: number[], columns: any[], elementId: string | undefined, matrix: string[][]) => {
        nextCell: "" | Element | null | undefined;
        elementToFocus: string | null | undefined;
    };
    getPrevEditableCell: (currentIdIndexes: number[], columns: any[], elementId: string | undefined, matrix: string[][]) => {
        prevCell: "" | Element | null | undefined;
        elementToFocus: string | null | undefined;
    };
    getClosestCellNavId: (element: HTMLElement) => string | null;
};

/** @hidden */
export declare interface TableKeyDownEvent<T> extends BaseEvent<T> {
    /**
     * The current leaf data items.
     */
    dataItems: any[];
    /**
     * Selection mode.
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
}

/** @hidden */
export declare type TableSelectableMode = 'single' | 'multiple';

/** @hidden */
export declare interface TableSelectableSettings {
    /**
     * Determines if selection is allowed.
     *
     * @default true
     */
    enabled?: boolean;
    /**
     * The available values are:
     * * `single`
     * * `multiple`
     *
     * @default "multiple"
     */
    mode?: TableSelectableMode;
    /**
     * Determines if cell selection is allowed.
     *
     * @default false
     */
    cell?: boolean;
    /**
     * Determines if drag selection is allowed.
     *
     * @default false
     */
    drag?: boolean;
}

/** @hidden */
export declare const TableSelection: (props: TableSelectionProps) => JSX.Element;

/** @hidden */
export declare interface TableSelectionChangeEvent<T> extends BaseEvent<T>, TableDragSelectionReleaseEvent {
    /**
     * The data item which was selected or deselected when the checkbox selection column is used. It will be `null` when the row or cell selection is used.
     */
    dataItem: any;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
    /**
     * The current component leaf data items.
     */
    dataItems: any[];
}

/** @hidden */
export declare interface TableSelectionProps {
    children: any;
    selectable?: TableSelectableSettings;
    onRelease: (options: TableDragSelectionReleaseEvent) => void;
    childRef?: (childElement: HTMLElement) => void;
}

/**
 * The TextFilter component used for editing text value of FilterDescriptor object.
 */
export declare class TextFilter extends React_2.Component<TextFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: default_2.Validator<object>;
        onFilterChange: default_2.Validator<(...args: any[]) => any>;
        ariaLabel: default_2.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class TextFilterCell extends TextFilterCell_base {
}

declare const TextFilterCell_base: React_2.ComponentClass<FilterComponentProps_2, any>;

/**
 * The props of the TextFilter component.
 */
export declare interface TextFilterProps {
    /**
     * The FilterDescriptor object which will be edited.
     */
    filter: FilterDescriptor;
    /**
     * The FilterChange event, triggered while editing the FilterOperator.
     */
    onFilterChange: (event: {
        nextFilter: FilterDescriptor;
    }) => void;
    /**
     * The accessible label of the component.
     */
    ariaLabel?: string;
}

/**
 * @hidden
 */
export declare interface TreeColumnBaseProps<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends ColumnBaseProps<C> {
    /**
     * A collection of child columns.
     */
    children?: TreeColumnBaseProps<C, H, F>[];
    /**
     * The column menu component. Pass the [ColumnMenuTextColumn]({% slug api_data-tools_columnmenutextcolumn %}),
     * [ColumnMenuNumericColumn]({% slug api_data-tools_columnmenunumericcolumn %}),
     * [ColumnMenuDateColumn]({% slug api_data-tools_columnmenudatecolumn %}),
     * [ColumnMenuBooleanColumn]({% slug api_data-tools_columnmenubooleancolumn %})
     * or a custom component base on the type of the column data.
     */
    columnMenu?: React.ComponentType<ColumnMenuProps>;
    /**
     * If set to `true`, the column will render the icons that are used for expanding and collapsing child rows.
     */
    expandable?: boolean;
    /**
     * Defines the component that will be rendered as an edit cell.
     */
    editCell?: ComponentType<C>;
    /**
     * Defines the component that will be rendered as a header cell.
     * If not set, a `HeaderCell` will be rendered by default.
     */
    headerCell?: ComponentType<H>;
    /**
     * **Deprecated**. Use `filterCell` prop instead.
     */
    filter?: ComponentType<F>;
    /**
     * Defines the component that will be rendered as a filter cell.
     */
    filterCell?: ComponentType<F>;
}

/**
 * Creates a flat data array from the passed tree dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {string} expandField - The field which points to the expanded value of each data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are in a flat structure.
 */
export declare const treeToFlat: (data: any[], expandField: string, subItemsField: string) => any[];

/**
 * @hidden
 */
export declare const unaryOperator: (operator: any) => boolean;

/**
 * @hidden
 */
export declare function updateLeft(columnsMap: number[][], columns: Array<{
    parentIndex: number;
    colSpan?: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, generateLeft?: boolean): void;

/**
 * @hidden
 */
export declare function updateRight(columnsMap: number[][], columns: Array<{
    parentIndex: number;
    colSpan?: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, generateRight?: boolean): void;

/**
 * A hook that provides functionality for managing local data with built-in support for filtering, sorting, paging, and grouping.
 *
 * @template T - The type of data items in the data source. Defaults to any.
 * @param {DataSourceProps<T>} props - The configuration options for the data source.
 * @returns {DataSource<T>} An object containing data management methods and properties.
 *
 * @example
 * ```tsx
 * interface Product {
 *   ProductID: number;
 *   ProductName: string;
 *   UnitPrice: number;
 * }
 *
 * const dataSource = useDataSource<Product>({
 *   defaultData: products,
 *   defaultSort: [{ field: 'UnitPrice', dir: 'desc' }],
 *   defaultSkip: 0,
 *   take: 10,
 *   schema: {
 *     model: {
 *       id: 'ProductID'
 *     }
 *   }
 * });
 *
 * return (
 *   <Grid
 *     data={dataSource.data}
 *     total={dataSource.total}
 *     {...dataSource.dataState}
 *     onDataStateChange={(event) => {
 *       dataSource.setDataState(event.dataState);
 *     }}
 *   >
 *     <GridColumn field="ProductID" title="ID" />
 *     <GridColumn field="ProductName" title="Product Name" />
 *   </Grid>
 * );
 * ```
 */
export declare const useDataSource: <T extends object = any>(props: DataSourceProps<T>) => DataSource<T>;

/**
 * A specialized version of useRemoteDataSource tailored for working with OData services.
 * It automatically handles the construction of OData queries and the processing of OData responses.
 *
 * @template T - The type of data items in the data source. Defaults to any.
 * @param {RemoteDataSourceProps<T>} props - The configuration options for the OData data source.
 * @returns {RemoteDataSource<T>} An object containing all the properties and methods from useRemoteDataSource with OData-specific defaults for transport and schema configurations.
 *
 * @example
 * ```tsx
 * interface Product {
 *   ProductID: number;
 *   ProductName: string;
 *   UnitPrice: number;
 * }
 *
 * const dataSource = useODataDataSource<Product>({
 *   take: 10,
 *   skip: 0,
 *   transport: {
 *     read: {
 *       url: 'https://demos.telerik.com/service/v2/odata/Products'
 *     }
 *   },
 *   schema: {
 *     model: {
 *       id: 'ProductID'
 *     }
 *   }
 * });
 * ```
 */
export declare const useODataDataSource: <T extends object = any>(props: RemoteDataSourceProps<T>) => RemoteDataSource<T>;

/**
 * A hook that extends the functionality of useDataSource by adding support for remote data operations.
 * It enables you to connect to remote endpoints and perform CRUD operations while managing the data state locally.
 *
 * @template T - The type of data items in the data source
 * @param {RemoteDataSourceProps<T>} props - The configuration options for the remote data source.
 * @returns {RemoteDataSource<T>} An object containing all the properties and methods from useDataSource plus additional methods for interacting with remote data.
 */
export declare const useRemoteDataSource: <T extends object = any>(props: RemoteDataSourceProps<T>) => RemoteDataSource<T>;

/**
 * @hidden
 */
export declare const useTableKeyboardNavigation: (elementId: string, navigatable?: boolean) => {
    tabIndex?: undefined;
    "data-keyboardnavlevel"?: undefined;
    "data-keyboardnavid"?: undefined;
} | {
    tabIndex: number;
    "data-keyboardnavlevel": number;
    "data-keyboardnavid": string;
};

/**
 * @hidden
 */
declare function waitForElementToBeVisible(selector: string, parentElement: Element | null, timeout?: number): Promise<boolean | Element>;

export { }
