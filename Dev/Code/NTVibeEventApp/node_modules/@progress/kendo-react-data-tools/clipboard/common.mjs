/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { getter as D, isArray as b } from "@progress/kendo-react-common";
var C = /* @__PURE__ */ ((t) => (t.copy = "copy", t.cut = "cut", t.paste = "paste", t))(C || {});
const E = (t, n, e, a) => {
  const s = D(a), c = t.data.findIndex((i) => s(i) === s(n[0].dataItem)) || 0, o = n.length < 2 ? e : n.length;
  return t.data.filter((i, l) => l >= c && l < c + o) || [];
}, K = (t) => (t == null ? void 0 : t.map((e) => e.fields.map((a) => e.dataItem[a].toString()))) || [], v = (t, n) => {
  var i, l;
  const { event: e } = t, a = n.includes(`
`) ? `
` : null, s = (i = e.cellDelimiter) != null ? i : "	", c = (l = e.newLineDelimiter) != null ? l : `\r
`, o = n.includes(c) ? c : a;
  return (o ? n.split(o) : [n]).map((r) => r.includes(s) ? r.split(s) : [r]);
}, F = (t, n) => {
  var e;
  return ((e = t.event.nativeEvent) == null ? void 0 : e.type) === "paste" ? v(t, n) : K(t.previousCopiedItems);
}, S = (t, n) => {
  var u, h, g;
  const { event: e } = t, a = e.dataItem, s = (h = (u = t.dataItemKey) != null ? u : e.dataItemKey) != null ? h : "", c = D(s), o = a && !a.selected && e.field ? [{ dataItem: e.dataItem, fields: [e.field] }] : w(t), d = o.length ? o[0].fields[0] : (g = e.columns[0].field) != null ? g : "", i = e.columns.map((I) => {
    var f;
    return (f = I.field) != null ? f : "";
  }), l = i.indexOf(d), r = F(t, n), p = E(t, o, r.length, s);
  return r.slice(0, p.length).map((I, f) => {
    const P = l + I.length, x = i.slice(l, P), y = { [s]: c(p[f]) };
    return x.forEach((L, T) => y[L] = I[T]), {
      dataItem: y,
      fields: x
    };
  });
}, $ = (t, n) => {
  if (!n.length)
    return null;
  let e = "";
  return n.forEach((a, s, c) => e += `${t[a]}${s < c.length - 1 ? "	" : ""}`), e;
}, O = (t, n, e) => {
  var o, d;
  const a = (o = e.cellDelimiter) != null ? o : "	", s = (d = e.newLineDelimiter) != null ? d : `\r
`;
  return `${n.join(a)}${s}${t}`;
}, w = (t) => {
  var i, l;
  const { event: n, selectedState: e, data: a } = t, s = (l = (i = t.dataItemKey) != null ? i : n.dataItemKey) != null ? l : "", c = D(s), o = {}, d = [];
  return Object.entries(e).forEach(([r, p]) => {
    o[r] = b(p) ? p.map((m) => n.columns[m]).filter((m) => !m.declarationIndex || m.declarationIndex >= 0) : n.columns.filter((m) => !m.declarationIndex || m.declarationIndex >= 0);
  }), a == null || a.map((r) => {
    const p = c(r) || "";
    return o[p] && d.push({
      dataItem: r,
      fields: o[p].map((m) => {
        var u;
        return (u = m.field) != null ? u : "";
      })
    }), r;
  }), d;
}, R = (t, n) => {
  var s, c;
  const e = (s = n.newLineDelimiter) != null ? s : `\r
`, a = t.map((o, d) => {
    var l;
    let i = (l = $(o.dataItem, o.fields)) != null ? l : "";
    return n.copyHeaders && d === 0 && (i = O(i, o.fields, n)), i ? [i] : [];
  }).join(e);
  return (c = navigator.clipboard) == null || c.writeText(a), a;
}, j = (t, n) => {
  let e = "";
  if (t.type === "paste") {
    const a = t.nativeEvent ? t.nativeEvent.clipboardData : "";
    e = a ? a.getData("text").trim() : "";
  } else
    e = R(n, t);
  return e;
}, H = (t) => {
  const { event: n } = t, e = w(t) || [], a = j(n, e) || "", s = n.type === "paste" ? S(t, a) || [] : [];
  return {
    copiedItems: e,
    pastedItems: s,
    clipboardData: a
  };
};
export {
  C as ClipboardActionType,
  O as addHeaders,
  j as getClipboardData,
  v as getClipboardItemsToPaste,
  R as getClipboardText,
  F as getItemsToPaste,
  E as getItemsToUpdateOnPaste,
  S as getPastedItems,
  K as getPreviouslyCopiedItemsData,
  w as getSelectedItems,
  $ as itemToString,
  H as populateClipboardData
};
