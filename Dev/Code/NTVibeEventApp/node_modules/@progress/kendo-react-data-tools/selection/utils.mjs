/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { getter as K, mapTree as k, extendDataItem as O, Keys as i, hasRelativeStackingContext as B } from "@progress/kendo-react-common";
import { TABLE_PREVENT_SELECTION_ELEMENT as M, TABLE_ROW_INDEX_ATTRIBUTE as F, TABLE_COL_INDEX_ATTRIBUTE as j } from "./constants.mjs";
const G = "items", y = {}, U = (e, t) => !e || Array.isArray(e) && e.length === 0 ? [t] : e.findIndex((d) => d === t) > -1 ? e.filter((d) => d !== t) : [...e, t], J = (e) => {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(M))
      return !0;
    t = t.parentElement;
  }
  return !1;
}, _ = (e, t) => {
  let o = e;
  for (; o; ) {
    if (o.tagName === t)
      return o;
    if (o.tagName === "TABLE")
      return null;
    o = o.parentElement;
  }
  return null;
}, X = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(F);
  return t ? parseInt(t, 10) : void 0;
}, V = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(j);
  return t ? parseInt(t, 10) : void 0;
}, Q = (e) => {
  const t = e.subItemsField || G, o = K(e.dataItemKey);
  return k(
    e.data,
    t,
    (d) => O(d, t, {
      [e.selectedField]: e.selectedState[o(d)]
    })
  );
}, Y = (e) => {
  const { event: t, dataItemKey: o, selectedState: d } = e, { syntheticEvent: a, nativeEvent: n, dataItems: I, componentId: s, mode: f, cell: g, selectedField: p } = t, { target: T, ctrlKey: w, metaKey: S, altKey: u, shiftKey: v } = n;
  if (a.isDefaultPrevented() && !v || n.keyCode !== i.space && n.keyCode !== i.enter && n.keyCode !== i.right && n.keyCode !== i.left && n.keyCode !== i.up && n.keyCode !== i.down)
    return d;
  a.preventDefault();
  const h = _(T, "TD"), E = _(T, "TR");
  let r = V(h), m = X(E), l = {};
  return h && E && m !== void 0 && r !== void 0 && (n.keyCode === i.right && r++, n.keyCode === i.left && r--, n.keyCode === i.down && m++, n.keyCode === i.up && m--, l = b({
    selectedState: d,
    dataItemKey: o,
    event: {
      ctrlKey: w,
      metaKey: S,
      altKey: u,
      shiftKey: v,
      dataItems: I,
      cell: g,
      mode: f,
      selectedField: p,
      componentId: s,
      startColIndex: r,
      endColIndex: r,
      startRowIndex: m,
      endRowIndex: m,
      isDrag: !1,
      syntheticEvent: a,
      nativeEvent: n,
      target: t.target,
      dataItem: null
    }
  })), l;
}, b = (e) => {
  const { event: t, dataItemKey: o, selectedState: d } = e, {
    dataItems: a,
    startRowIndex: n,
    endRowIndex: I,
    startColIndex: s,
    endColIndex: f,
    cell: g,
    isDrag: p,
    ctrlKey: T,
    shiftKey: w,
    metaKey: S,
    componentId: u,
    mode: v,
    dataItem: h
  } = t, E = K(o);
  let r = {};
  const m = h !== null;
  if (v === "single") {
    const l = a.slice(n, n + 1)[0], x = E(l);
    y[u] = {
      rowIndex: n,
      colIndex: s
    }, x !== void 0 && (r[x] = g ? [s] : !0);
  } else if (p || !w && !T && !S && !m) {
    p || (y[u] = {
      rowIndex: n,
      colIndex: s
    });
    const l = [];
    for (let c = s; c <= f; c++)
      l.push(c);
    a.slice(n, I + 1).forEach((c) => {
      const D = E(c);
      D !== void 0 && (r[D] = g ? [...l] : !0);
    });
  } else if (T || S || m) {
    y[u] = {
      rowIndex: n,
      colIndex: s
    };
    const x = a.slice(n, I + 1)[0], c = E(x);
    c !== void 0 && (r = { ...d }, r[c] = g && !m ? U(r[c], s) : !r[c]);
  } else if (w) {
    const l = y[u] && y[u].rowIndex || 0, x = y[u] && y[u].colIndex || 0, c = Math.min(l, n, I), D = Math.max(l, n, I), L = Math.min(x, s, f), N = Math.max(x, s, f), R = [];
    for (let C = L; C <= N; C++)
      R.push(C);
    a.slice(c, D + 1).forEach((C) => {
      const A = E(C);
      A !== void 0 && (r[A] = g ? [...R] : !0);
    });
  }
  return r;
}, H = B(), Z = (e) => {
  if (!e || !H)
    return null;
  let t = e.parentElement;
  for (; t; ) {
    if (window.getComputedStyle(t).transform !== "none")
      return t;
    t = t.parentElement;
  }
}, $ = (e) => {
  if (e && e.ownerDocument && e !== e.ownerDocument.body) {
    const t = e.getBoundingClientRect();
    return {
      left: t.left - e.scrollLeft,
      top: t.top - e.scrollTop
    };
  }
  return { left: 0, top: 0 };
}, P = (e) => {
  var n, I, s, f;
  const t = typeof e == "object" ? (n = e.enabled) != null ? n : !0 : e != null ? e : !1, o = typeof e == "object" && (I = e.drag) != null ? I : !1, d = typeof e == "object" && (s = e.mode) != null ? s : "multiple", a = typeof e == "object" && (f = e.cell) != null ? f : !1;
  return { enabled: t, drag: o, mode: d, cell: a };
};
export {
  _ as closestTagName,
  V as getColumnIndex,
  $ as getOffset,
  X as getRowIndex,
  b as getSelectedState,
  Y as getSelectedStateFromKeyDown,
  P as getSelectionOptions,
  J as isInNonSelectable,
  Z as relativeContextElement,
  Q as setSelectedState
};
