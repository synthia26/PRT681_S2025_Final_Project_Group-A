/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { validatePackage as Me, deepMerge as le, getter as ce, useImmediateInheritState as V, clone as ue } from "@progress/kendo-react-common";
import { useDataSource as Te } from "./use-data-source.mjs";
import { packageMetadata as be } from "../package-metadata.mjs";
const De = { data: (p) => p, total: (p) => p.length }, Se = {
  create: {
    method: "POST",
    contentType: "application/json"
  },
  read: {
    method: "GET"
  },
  update: {
    method: "PUT",
    contentType: "application/json"
  },
  delete: {
    method: "DELETE"
  }
}, B = (p, A) => {
  const g = typeof p == "function" ? p(A) : p;
  return new URL(g);
}, C = (p, A, g) => typeof p == "function" ? p(A) : g || p ? { ...g, ...p } : void 0, H = (p, A) => {
  typeof A == "object" ? Object.keys(A).forEach((g) => {
    p.searchParams.append(g, A[g]);
  }) : typeof A == "string" && (p.search = A);
}, K = async ({
  url: p,
  method: A,
  contentType: g,
  body: Q,
  onError: L,
  onSuccess: W
}) => {
  var i;
  const N = await fetch(p, {
    method: A,
    headers: g ? { "Content-Type": g } : {},
    ...Q ? { body: JSON.stringify(Q) } : {}
  });
  return N.ok ? W(
    (i = N.headers.get("Content-Type")) != null && i.includes("application/json") ? await N.json() : await N.text()
  ) : L == null ? void 0 : L(await N.json());
}, Ie = (p) => {
  Me(be, { component: "useRemoteDataSource" });
  const {
    defaultTotal: A,
    serverFiltering: g = !0,
    serverSorting: Q = !0,
    serverPaging: L = !0,
    serverGrouping: W = !0,
    ...N
  } = p, i = le({}, De, p.schema), t = le(
    {},
    Se,
    p.transport
  ), de = typeof i.data == "function" ? i.data : i.data ? ce(i.data) : (a) => a, ie = typeof i.total == "function" ? i.total : i.total ? ce(i.total) : (a) => a, c = typeof (i == null ? void 0 : i.errors) == "function" ? (a) => i.errors(a) : i != null && i.errors ? ce(i == null ? void 0 : i.errors) : (a) => {
  }, k = ce(String(i.model.id)), F = V(/* @__PURE__ */ new Map(), p.reads), D = V(/* @__PURE__ */ new Map(), p.creates), R = V(/* @__PURE__ */ new Map(), p.updates), x = V(/* @__PURE__ */ new Map(), p.deletes), w = V(/* @__PURE__ */ new Map()), S = V(/* @__PURE__ */ new Map()), ne = (a) => {
    F.value = a;
  }, X = (a) => {
    D.value = a;
  }, oe = (a) => {
    R.value = a;
  }, re = (a) => {
    x.value = a;
  }, q = (a) => {
    w.value = a;
  }, Y = (a) => {
    S.value = a;
  }, z = Te({
    sortable: !Q,
    pageable: !L,
    filterable: !g,
    groupable: !W,
    get data() {
      return Array.from(new Map([...D.value, ...F.value, ...R.value]).values()).filter(
        (a) => !x.value.has(k(a))
      );
    },
    ...N,
    schema: i
  }), se = (a) => {
    const e = /* @__PURE__ */ new Map();
    z.setData(a), a.forEach((n) => {
      const o = k(n);
      e.set(o, n);
    }), ne(e);
  }, O = (a) => {
    const { error: e, data: n } = a;
    if (!e)
      return;
    let o = null;
    n && (o = k(n)), S.value.has(o) || S.value.set(o, []);
    const s = S.value.get(o) || [];
    s.push(e), S.value.set(o, s), Y(new Map(S.value));
  }, ve = (a) => {
    const { error: e } = a;
    S.value.forEach((n, o) => {
      const s = n.filter((f) => f !== e);
      s.length === 0 ? S.value.delete(o) : S.value.set(o, s);
    }), Y(new Map(S.value));
  }, pe = (a) => {
    const { data: e } = a, n = k(e);
    S.value.delete(n), Y(new Map(S.value));
  }, fe = () => {
    S.value.clear(), Y(new Map(S.value));
  }, we = (a) => {
    const { data: e } = a, n = k(e);
    D.value.set(n, e), X(new Map(D.value));
    const o = new Set(Object.keys(e).filter((s) => {
      var f;
      return s !== ((f = i.model) == null ? void 0 : f.id);
    }));
    w.value.set(n, o), q(new Map(w.value));
  }, ye = (a) => {
    const { data: e, field: n } = a, o = k(e);
    if (D.value.has(o)) {
      const d = D.value.get(o);
      D.value.set(o, { ...d, ...e }), X(new Map(D.value));
      const r = w.value.get(o) || /* @__PURE__ */ new Set();
      n ? r.add(n) : Object.keys(e).forEach((j) => {
        var h;
        j !== ((h = i.model) == null ? void 0 : h.id) && r.add(j);
      }), w.value.set(o, r), q(new Map(w.value));
      return;
    }
    const s = R.value.has(o) ? R.value.get(o) : F.value.has(o) ? F.value.get(o) : {};
    R.value.set(o, { ...s, ...e }), oe(new Map(R.value));
    const f = w.value.get(o) || /* @__PURE__ */ new Set();
    n ? f.add(n) : Object.keys(e).forEach((d) => {
      var r;
      d !== ((r = i.model) == null ? void 0 : r.id) && f.add(d);
    }), w.value.set(o, f), q(new Map(w.value));
  }, me = (a) => {
    const { data: e } = a, n = k(e);
    if (D.value.has(n)) {
      D.value.delete(n), X(new Map(D.value)), w.value.delete(n), q(new Map(w.value));
      return;
    }
    x.value.set(n, e), re(new Map(x.value));
  }, Z = (a) => {
    const { data: e } = a, n = k(e);
    D.value.delete(n), X(new Map(D.value)), w.value.delete(n), q(new Map(w.value));
  }, $ = (a) => {
    const { data: e, field: n } = a, o = k(e);
    if (R.value.has(o))
      if (n) {
        const s = w.value.get(o);
        s && (s.delete(n), s.size === 0 ? (R.value.delete(o), w.value.delete(o)) : w.value.set(o, s), oe(new Map(R.value)), q(new Map(w.value)));
      } else
        R.value.delete(o), oe(new Map(R.value)), w.value.delete(o), q(new Map(w.value));
  }, E = (a) => {
    const { data: e } = a, n = k(e);
    x.value.delete(n), re(new Map(x.value)), w.value.delete(n), q(new Map(w.value));
  }, ee = (a) => {
    const { data: e } = a, n = k(e);
    F.value.set(n, e), ne(new Map(F.value));
  }, te = (a) => {
    const { data: e } = a, n = k(e);
    F.value.set(n, e), ne(new Map(F.value));
  }, ae = (a) => {
    const { data: e } = a, n = k(e);
    F.value.delete(n), ne(new Map(F.value));
  }, he = {
    // CRUD collections
    get reads() {
      return F.value;
    },
    get creates() {
      return D.value;
    },
    get updates() {
      return R.value;
    },
    get deletes() {
      return x.value;
    },
    get dirty() {
      return w.value;
    },
    get errors() {
      return S.value;
    },
    // CRUD operations
    addError: O,
    removeError: ve,
    removeErrors: pe,
    removeAllErrors: fe,
    read: async (a) => {
      var y, I, M, m, J, P, G;
      if (!(t != null && t.read))
        throw new Error("transport.read is not defined");
      const e = (y = a == null ? void 0 : a.filter) != null ? y : z.filter, n = (I = a == null ? void 0 : a.skip) != null ? I : z.skip, o = (M = a == null ? void 0 : a.take) != null ? M : z.take, s = (m = a == null ? void 0 : a.sort) != null ? m : z.sort, f = (J = a == null ? void 0 : a.group) != null ? J : z.group;
      if (typeof t.read == "function") {
        const b = await t.read({
          ...g && e !== void 0 && { filter: e },
          ...L && n !== void 0 && { skip: n },
          ...L && o !== void 0 && { take: o },
          ...Q && s !== void 0 && { sort: s },
          ...W && f !== void 0 && { group: f }
        });
        return se(b), b;
      }
      const d = {
        ...g && e !== void 0 && { filter: e },
        ...L && n !== void 0 && { skip: n },
        ...L && o !== void 0 && { take: o },
        ...Q && s !== void 0 && { sort: s },
        ...W && f !== void 0 && { group: f }
      }, r = B(t.read.url), j = t.read.onError, h = t.read.onResponse, _ = t.read.onSuccess, T = C(t.read.data), u = ((G = (P = t == null ? void 0 : t.read) == null ? void 0 : P.parameterMap) == null ? void 0 : G.call(P, { ...d, ...T })) || {
        ...d,
        ...T
      };
      H(r, u);
      try {
        const b = await K({
          url: r,
          method: t.read.method,
          contentType: t.read.contentType,
          body: T,
          onError: async (l) => {
            var U;
            const v = (U = await (j == null ? void 0 : j(l))) != null ? U : c == null ? void 0 : c(l);
            return v && O({ error: v }), [];
          },
          onSuccess: async (l) => {
            var U;
            const v = (U = await (h == null ? void 0 : h(l))) != null ? U : de(l);
            return z.setTotal(await ie(l)), se(v), await (_ == null ? void 0 : _(v)), v;
          }
        });
        return b != null ? b : [];
      } catch (b) {
        return console.error(b), [];
      }
    },
    create: we,
    update: ye,
    delete: me,
    // Renamed to "remove" internally to avoid JS keyword
    sync: async () => {
      await Promise.all(
        Array.from(D.value).map(async ([a, e]) => {
          var n, o, s, f;
          if (t != null && t.create)
            if (typeof t.create == "function")
              try {
                const d = await t.create({ data: e });
                ee({ data: d || e }), Z({ data: e });
              } catch (d) {
                const r = c == null ? void 0 : c(d);
                r && O({ error: r, data: e });
              }
            else {
              const d = B(t.create.url, e), r = C(t.create.data, e, ue(e)), j = (f = (s = (o = (n = t == null ? void 0 : t.create) == null ? void 0 : n.parameterMap) == null ? void 0 : o.call(n, r)) != null ? s : r) != null ? f : {}, h = t.create.onError, _ = t.create.onResponse, T = t.create.onSuccess;
              H(d, j);
              try {
                await K({
                  url: d,
                  method: t.create.method,
                  contentType: t.create.contentType,
                  body: r,
                  onError: async (u) => {
                    var I;
                    const y = (I = await (h == null ? void 0 : h(u))) != null ? I : c == null ? void 0 : c(u);
                    y && O({ error: y, data: e });
                  },
                  onSuccess: async (u) => {
                    const y = _ ? await _(u) : u;
                    ee({ data: y || e }), Z({ data: e }), await (T == null ? void 0 : T(y || e));
                  }
                });
              } catch (u) {
                console.error(u);
              }
            }
        })
      ), await Promise.all(
        Array.from(R.value).map(async ([a, e]) => {
          var n, o, s, f;
          if (t != null && t.update)
            if (typeof t.update == "function")
              try {
                const d = await t.update({ data: e });
                te({ data: d || e }), $({ data: e });
              } catch (d) {
                const r = c == null ? void 0 : c(d);
                r && O({ error: r, data: e });
              }
            else {
              const d = B(t.update.url, e), r = C(t.update.data, e, e), j = (f = (s = (o = (n = t == null ? void 0 : t.update) == null ? void 0 : n.parameterMap) == null ? void 0 : o.call(n, r)) != null ? s : r) != null ? f : {}, h = t.update.onError, _ = t.update.onResponse, T = t.update.onSuccess;
              H(d, j);
              try {
                await K({
                  url: d,
                  method: t.update.method,
                  contentType: t.update.contentType,
                  body: r,
                  onError: async (u) => {
                    var I;
                    const y = (I = await (h == null ? void 0 : h(u))) != null ? I : c == null ? void 0 : c(u);
                    y && O({ error: y, data: e });
                  },
                  onSuccess: async (u) => {
                    const y = _ ? await _(u) : u;
                    return te({ data: y || e }), $({ data: e }), await (T == null ? void 0 : T(y || e)), y;
                  }
                });
              } catch (u) {
                console.error(u);
              }
            }
        })
      ), await Promise.all(
        Array.from(x.value).map(async ([a, e]) => {
          var n, o, s, f;
          if (t != null && t.delete)
            if (typeof t.delete == "function")
              try {
                await t.delete({ data: e }), ae({ data: e }), E({ data: e });
              } catch (d) {
                const r = c == null ? void 0 : c(d);
                r && O({ error: r, data: e });
              }
            else {
              const d = B(t.delete.url, e), r = C(t.delete.data, e, e), j = (f = (s = (o = (n = t == null ? void 0 : t.delete) == null ? void 0 : n.parameterMap) == null ? void 0 : o.call(n, r)) != null ? s : r) != null ? f : {}, h = t.delete.onError, _ = t.delete.onResponse, T = t.delete.onSuccess;
              H(d, j);
              try {
                await K({
                  url: d,
                  method: t.delete.method,
                  contentType: t.delete.contentType,
                  body: r,
                  onError: async (u) => {
                    var I;
                    const y = (I = await (h == null ? void 0 : h(u))) != null ? I : c == null ? void 0 : c(u);
                    y && O({ error: y, data: e });
                  },
                  onSuccess: async (u) => {
                    const y = _ ? await _(u) : u;
                    return ae({ data: Object.keys(y).length !== 0 ? y : e }), E({ data: e }), await (T == null ? void 0 : T(u || e)), u;
                  }
                });
              } catch (u) {
                console.error(u);
              }
            }
        })
      );
    },
    syncItem: async (a) => {
      var o, s, f, d, r, j, h, _, T, u, y, I;
      const { data: e } = a, n = k(e);
      if (D.value.has(n)) {
        if (!(t != null && t.create))
          return;
        if (typeof t.create == "function")
          try {
            const M = await t.create({ data: e });
            ee({ data: M || e }), Z({ data: e });
          } catch (M) {
            const m = c == null ? void 0 : c(M);
            m && O({ error: m, data: e });
          }
        else {
          const M = B(t.create.url, e), m = C(t.create.data, e, ue(e)), J = (d = (f = (s = (o = t == null ? void 0 : t.create) == null ? void 0 : o.parameterMap) == null ? void 0 : s.call(o, m)) != null ? f : m) != null ? d : {}, P = t.create.onError, G = t.create.onResponse, b = t.create.onSuccess;
          H(M, J);
          try {
            await K({
              url: M,
              method: t.create.method,
              contentType: t.create.contentType,
              body: m,
              onError: async (l) => {
                var U;
                const v = (U = await (P == null ? void 0 : P(l))) != null ? U : c == null ? void 0 : c(l);
                v && O({ error: v, data: e });
              },
              onSuccess: async (l) => {
                const v = G ? await G(l) : l;
                return ee({ data: v || e }), Z({ data: e }), await (b == null ? void 0 : b(v || e)), v;
              }
            });
          } catch (l) {
            console.error(l);
          }
        }
      }
      if (R.value.has(n)) {
        if (!(t != null && t.update))
          return;
        if (typeof t.update == "function")
          try {
            const M = await t.update({ data: e });
            te({ data: M || e }), $({ data: e });
          } catch (M) {
            const m = c == null ? void 0 : c(M);
            m && O({ error: m, data: e });
          }
        else {
          const M = B(t.update.url, e), m = C(t.update.data, e, e), J = (_ = (h = (j = (r = t == null ? void 0 : t.update) == null ? void 0 : r.parameterMap) == null ? void 0 : j.call(r, m)) != null ? h : m) != null ? _ : {}, P = t.update.onError, G = t.update.onResponse, b = t.update.onSuccess;
          H(M, J);
          try {
            await K({
              url: M,
              method: t.update.method,
              contentType: t.update.contentType,
              body: m,
              onError: async (l) => {
                var U;
                const v = (U = await (P == null ? void 0 : P(l))) != null ? U : c == null ? void 0 : c(l);
                v && O({ error: v, data: e });
              },
              onSuccess: async (l) => {
                const v = G ? await G(l) : l;
                return te({ data: v || e }), $({ data: e }), await (b == null ? void 0 : b(v || e)), v;
              }
            });
          } catch (l) {
            console.error(l);
          }
        }
      }
      if (x.value.has(n)) {
        if (!(t != null && t.delete))
          return;
        if (typeof t.delete == "function")
          try {
            await t.delete({ data: e }), ae({ data: e }), E({ data: e });
          } catch (M) {
            const m = c == null ? void 0 : c(M);
            m && O({ error: m, data: e });
          }
        else {
          const M = B(t.delete.url, e), m = C(t.delete.data, e, e), J = (I = (y = (u = (T = t == null ? void 0 : t.delete) == null ? void 0 : T.parameterMap) == null ? void 0 : u.call(T, m)) != null ? y : m) != null ? I : {}, P = t.delete.onError, G = t.delete.onResponse, b = t.delete.onSuccess;
          H(M, J);
          try {
            await K({
              url: M,
              method: t.delete.method,
              contentType: t.delete.contentType,
              body: m,
              onError: async (l) => {
                var U;
                const v = (U = await (P == null ? void 0 : P(l))) != null ? U : c == null ? void 0 : c(l);
                v && O({ error: v, data: e });
              },
              onSuccess: async (l) => {
                const v = G ? await G(l) : l;
                return ae({ data: v || e }), E({ data: e }), await (b == null ? void 0 : b(v || e)), l;
              }
            });
          } catch (l) {
            console.error(l);
          }
        }
      }
    },
    removeCreate: Z,
    removeUpdate: $,
    removeDelete: E,
    pushCreate: ee,
    pushUpdate: te,
    pushDelete: ae,
    discard: () => {
      D.value.clear(), X(new Map(D.value)), R.value.clear(), oe(new Map(R.value)), x.value.clear(), re(new Map(x.value)), w.value.clear(), q(new Map(w.value)), S.value.clear(), Y(new Map(S.value));
    }
  };
  return Object.defineProperties(
    {},
    {
      ...Object.getOwnPropertyDescriptors(z),
      ...Object.fromEntries(
        Object.entries(he).map(([a, e]) => [
          a,
          {
            value: e,
            writable: !0,
            enumerable: !0,
            configurable: !0
          }
        ])
      )
    }
  );
};
export {
  Ie as useRemoteDataSource
};
