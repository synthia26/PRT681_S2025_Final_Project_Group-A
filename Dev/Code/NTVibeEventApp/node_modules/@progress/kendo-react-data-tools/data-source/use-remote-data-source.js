/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const j=require("@progress/kendo-react-common"),we=require("./use-data-source.js"),me=require("../package-metadata.js"),he={data:p=>p,total:p=>p.length},Me={create:{method:"POST",contentType:"application/json"},read:{method:"GET"},update:{method:"PUT",contentType:"application/json"},delete:{method:"DELETE"}},B=(p,F)=>{const k=typeof p=="function"?p(F):p;return new URL(k)},H=(p,F,k)=>typeof p=="function"?p(F):k||p?{...k,...p}:void 0,K=(p,F)=>{typeof F=="object"?Object.keys(F).forEach(k=>{p.searchParams.append(k,F[k])}):typeof F=="string"&&(p.search=F)},Q=async({url:p,method:F,contentType:k,body:V,onError:L,onSuccess:W})=>{var i;const N=await fetch(p,{method:F,headers:k?{"Content-Type":k}:{},...V?{body:JSON.stringify(V)}:{}});return N.ok?W((i=N.headers.get("Content-Type"))!=null&&i.includes("application/json")?await N.json():await N.text()):L==null?void 0:L(await N.json())},Se=p=>{j.validatePackage(me.packageMetadata,{component:"useRemoteDataSource"});const{defaultTotal:F,serverFiltering:k=!0,serverSorting:V=!0,serverPaging:L=!0,serverGrouping:W=!0,...N}=p,i=j.deepMerge({},he,p.schema),t=j.deepMerge({},Me,p.transport),se=typeof i.data=="function"?i.data:i.data?j.getter(i.data):a=>a,ue=typeof i.total=="function"?i.total:i.total?j.getter(i.total):a=>a,c=typeof(i==null?void 0:i.errors)=="function"?a=>i.errors(a):i!=null&&i.errors?j.getter(i==null?void 0:i.errors):a=>{},O=j.getter(String(i.model.id)),q=j.useImmediateInheritState(new Map,p.reads),T=j.useImmediateInheritState(new Map,p.creates),R=j.useImmediateInheritState(new Map,p.updates),x=j.useImmediateInheritState(new Map,p.deletes),y=j.useImmediateInheritState(new Map),D=j.useImmediateInheritState(new Map),ne=a=>{q.value=a},X=a=>{T.value=a},oe=a=>{R.value=a},ce=a=>{x.value=a},z=a=>{y.value=a},Y=a=>{D.value=a},C=we.useDataSource({sortable:!V,pageable:!L,filterable:!k,groupable:!W,get data(){return Array.from(new Map([...T.value,...q.value,...R.value]).values()).filter(a=>!x.value.has(O(a)))},...N,schema:i}),re=a=>{const e=new Map;C.setData(a),a.forEach(n=>{const o=O(n);e.set(o,n)}),ne(e)},_=a=>{const{error:e,data:n}=a;if(!e)return;let o=null;n&&(o=O(n)),D.value.has(o)||D.value.set(o,[]);const s=D.value.get(o)||[];s.push(e),D.value.set(o,s),Y(new Map(D.value))},le=a=>{const{error:e}=a;D.value.forEach((n,o)=>{const s=n.filter(f=>f!==e);s.length===0?D.value.delete(o):D.value.set(o,s)}),Y(new Map(D.value))},de=a=>{const{data:e}=a,n=O(e);D.value.delete(n),Y(new Map(D.value))},ie=()=>{D.value.clear(),Y(new Map(D.value))},ve=a=>{const{data:e}=a,n=O(e);T.value.set(n,e),X(new Map(T.value));const o=new Set(Object.keys(e).filter(s=>{var f;return s!==((f=i.model)==null?void 0:f.id)}));y.value.set(n,o),z(new Map(y.value))},pe=a=>{const{data:e,field:n}=a,o=O(e);if(T.value.has(o)){const d=T.value.get(o);T.value.set(o,{...d,...e}),X(new Map(T.value));const r=y.value.get(o)||new Set;n?r.add(n):Object.keys(e).forEach(P=>{var h;P!==((h=i.model)==null?void 0:h.id)&&r.add(P)}),y.value.set(o,r),z(new Map(y.value));return}const s=R.value.has(o)?R.value.get(o):q.value.has(o)?q.value.get(o):{};R.value.set(o,{...s,...e}),oe(new Map(R.value));const f=y.value.get(o)||new Set;n?f.add(n):Object.keys(e).forEach(d=>{var r;d!==((r=i.model)==null?void 0:r.id)&&f.add(d)}),y.value.set(o,f),z(new Map(y.value))},fe=a=>{const{data:e}=a,n=O(e);if(T.value.has(n)){T.value.delete(n),X(new Map(T.value)),y.value.delete(n),z(new Map(y.value));return}x.value.set(n,e),ce(new Map(x.value))},Z=a=>{const{data:e}=a,n=O(e);T.value.delete(n),X(new Map(T.value)),y.value.delete(n),z(new Map(y.value))},$=a=>{const{data:e,field:n}=a,o=O(e);if(R.value.has(o))if(n){const s=y.value.get(o);s&&(s.delete(n),s.size===0?(R.value.delete(o),y.value.delete(o)):y.value.set(o,s),oe(new Map(R.value)),z(new Map(y.value)))}else R.value.delete(o),oe(new Map(R.value)),y.value.delete(o),z(new Map(y.value))},E=a=>{const{data:e}=a,n=O(e);x.value.delete(n),ce(new Map(x.value)),y.value.delete(n),z(new Map(y.value))},ee=a=>{const{data:e}=a,n=O(e);q.value.set(n,e),ne(new Map(q.value))},te=a=>{const{data:e}=a,n=O(e);q.value.set(n,e),ne(new Map(q.value))},ae=a=>{const{data:e}=a,n=O(e);q.value.delete(n),ne(new Map(q.value))},ye={get reads(){return q.value},get creates(){return T.value},get updates(){return R.value},get deletes(){return x.value},get dirty(){return y.value},get errors(){return D.value},addError:_,removeError:le,removeErrors:de,removeAllErrors:ie,read:async a=>{var w,U,M,m,J,g,G;if(!(t!=null&&t.read))throw new Error("transport.read is not defined");const e=(w=a==null?void 0:a.filter)!=null?w:C.filter,n=(U=a==null?void 0:a.skip)!=null?U:C.skip,o=(M=a==null?void 0:a.take)!=null?M:C.take,s=(m=a==null?void 0:a.sort)!=null?m:C.sort,f=(J=a==null?void 0:a.group)!=null?J:C.group;if(typeof t.read=="function"){const b=await t.read({...k&&e!==void 0&&{filter:e},...L&&n!==void 0&&{skip:n},...L&&o!==void 0&&{take:o},...V&&s!==void 0&&{sort:s},...W&&f!==void 0&&{group:f}});return re(b),b}const d={...k&&e!==void 0&&{filter:e},...L&&n!==void 0&&{skip:n},...L&&o!==void 0&&{take:o},...V&&s!==void 0&&{sort:s},...W&&f!==void 0&&{group:f}},r=B(t.read.url),P=t.read.onError,h=t.read.onResponse,I=t.read.onSuccess,S=H(t.read.data),l=((G=(g=t==null?void 0:t.read)==null?void 0:g.parameterMap)==null?void 0:G.call(g,{...d,...S}))||{...d,...S};K(r,l);try{const b=await Q({url:r,method:t.read.method,contentType:t.read.contentType,body:S,onError:async u=>{var A;const v=(A=await(P==null?void 0:P(u)))!=null?A:c==null?void 0:c(u);return v&&_({error:v}),[]},onSuccess:async u=>{var A;const v=(A=await(h==null?void 0:h(u)))!=null?A:se(u);return C.setTotal(await ue(u)),re(v),await(I==null?void 0:I(v)),v}});return b!=null?b:[]}catch(b){return console.error(b),[]}},create:ve,update:pe,delete:fe,sync:async()=>{await Promise.all(Array.from(T.value).map(async([a,e])=>{var n,o,s,f;if(t!=null&&t.create)if(typeof t.create=="function")try{const d=await t.create({data:e});ee({data:d||e}),Z({data:e})}catch(d){const r=c==null?void 0:c(d);r&&_({error:r,data:e})}else{const d=B(t.create.url,e),r=H(t.create.data,e,j.clone(e)),P=(f=(s=(o=(n=t==null?void 0:t.create)==null?void 0:n.parameterMap)==null?void 0:o.call(n,r))!=null?s:r)!=null?f:{},h=t.create.onError,I=t.create.onResponse,S=t.create.onSuccess;K(d,P);try{await Q({url:d,method:t.create.method,contentType:t.create.contentType,body:r,onError:async l=>{var U;const w=(U=await(h==null?void 0:h(l)))!=null?U:c==null?void 0:c(l);w&&_({error:w,data:e})},onSuccess:async l=>{const w=I?await I(l):l;ee({data:w||e}),Z({data:e}),await(S==null?void 0:S(w||e))}})}catch(l){console.error(l)}}})),await Promise.all(Array.from(R.value).map(async([a,e])=>{var n,o,s,f;if(t!=null&&t.update)if(typeof t.update=="function")try{const d=await t.update({data:e});te({data:d||e}),$({data:e})}catch(d){const r=c==null?void 0:c(d);r&&_({error:r,data:e})}else{const d=B(t.update.url,e),r=H(t.update.data,e,e),P=(f=(s=(o=(n=t==null?void 0:t.update)==null?void 0:n.parameterMap)==null?void 0:o.call(n,r))!=null?s:r)!=null?f:{},h=t.update.onError,I=t.update.onResponse,S=t.update.onSuccess;K(d,P);try{await Q({url:d,method:t.update.method,contentType:t.update.contentType,body:r,onError:async l=>{var U;const w=(U=await(h==null?void 0:h(l)))!=null?U:c==null?void 0:c(l);w&&_({error:w,data:e})},onSuccess:async l=>{const w=I?await I(l):l;return te({data:w||e}),$({data:e}),await(S==null?void 0:S(w||e)),w}})}catch(l){console.error(l)}}})),await Promise.all(Array.from(x.value).map(async([a,e])=>{var n,o,s,f;if(t!=null&&t.delete)if(typeof t.delete=="function")try{await t.delete({data:e}),ae({data:e}),E({data:e})}catch(d){const r=c==null?void 0:c(d);r&&_({error:r,data:e})}else{const d=B(t.delete.url,e),r=H(t.delete.data,e,e),P=(f=(s=(o=(n=t==null?void 0:t.delete)==null?void 0:n.parameterMap)==null?void 0:o.call(n,r))!=null?s:r)!=null?f:{},h=t.delete.onError,I=t.delete.onResponse,S=t.delete.onSuccess;K(d,P);try{await Q({url:d,method:t.delete.method,contentType:t.delete.contentType,body:r,onError:async l=>{var U;const w=(U=await(h==null?void 0:h(l)))!=null?U:c==null?void 0:c(l);w&&_({error:w,data:e})},onSuccess:async l=>{const w=I?await I(l):l;return ae({data:Object.keys(w).length!==0?w:e}),E({data:e}),await(S==null?void 0:S(l||e)),l}})}catch(l){console.error(l)}}}))},syncItem:async a=>{var o,s,f,d,r,P,h,I,S,l,w,U;const{data:e}=a,n=O(e);if(T.value.has(n)){if(!(t!=null&&t.create))return;if(typeof t.create=="function")try{const M=await t.create({data:e});ee({data:M||e}),Z({data:e})}catch(M){const m=c==null?void 0:c(M);m&&_({error:m,data:e})}else{const M=B(t.create.url,e),m=H(t.create.data,e,j.clone(e)),J=(d=(f=(s=(o=t==null?void 0:t.create)==null?void 0:o.parameterMap)==null?void 0:s.call(o,m))!=null?f:m)!=null?d:{},g=t.create.onError,G=t.create.onResponse,b=t.create.onSuccess;K(M,J);try{await Q({url:M,method:t.create.method,contentType:t.create.contentType,body:m,onError:async u=>{var A;const v=(A=await(g==null?void 0:g(u)))!=null?A:c==null?void 0:c(u);v&&_({error:v,data:e})},onSuccess:async u=>{const v=G?await G(u):u;return ee({data:v||e}),Z({data:e}),await(b==null?void 0:b(v||e)),v}})}catch(u){console.error(u)}}}if(R.value.has(n)){if(!(t!=null&&t.update))return;if(typeof t.update=="function")try{const M=await t.update({data:e});te({data:M||e}),$({data:e})}catch(M){const m=c==null?void 0:c(M);m&&_({error:m,data:e})}else{const M=B(t.update.url,e),m=H(t.update.data,e,e),J=(I=(h=(P=(r=t==null?void 0:t.update)==null?void 0:r.parameterMap)==null?void 0:P.call(r,m))!=null?h:m)!=null?I:{},g=t.update.onError,G=t.update.onResponse,b=t.update.onSuccess;K(M,J);try{await Q({url:M,method:t.update.method,contentType:t.update.contentType,body:m,onError:async u=>{var A;const v=(A=await(g==null?void 0:g(u)))!=null?A:c==null?void 0:c(u);v&&_({error:v,data:e})},onSuccess:async u=>{const v=G?await G(u):u;return te({data:v||e}),$({data:e}),await(b==null?void 0:b(v||e)),v}})}catch(u){console.error(u)}}}if(x.value.has(n)){if(!(t!=null&&t.delete))return;if(typeof t.delete=="function")try{await t.delete({data:e}),ae({data:e}),E({data:e})}catch(M){const m=c==null?void 0:c(M);m&&_({error:m,data:e})}else{const M=B(t.delete.url,e),m=H(t.delete.data,e,e),J=(U=(w=(l=(S=t==null?void 0:t.delete)==null?void 0:S.parameterMap)==null?void 0:l.call(S,m))!=null?w:m)!=null?U:{},g=t.delete.onError,G=t.delete.onResponse,b=t.delete.onSuccess;K(M,J);try{await Q({url:M,method:t.delete.method,contentType:t.delete.contentType,body:m,onError:async u=>{var A;const v=(A=await(g==null?void 0:g(u)))!=null?A:c==null?void 0:c(u);v&&_({error:v,data:e})},onSuccess:async u=>{const v=G?await G(u):u;return ae({data:v||e}),E({data:e}),await(b==null?void 0:b(v||e)),u}})}catch(u){console.error(u)}}}},removeCreate:Z,removeUpdate:$,removeDelete:E,pushCreate:ee,pushUpdate:te,pushDelete:ae,discard:()=>{T.value.clear(),X(new Map(T.value)),R.value.clear(),oe(new Map(R.value)),x.value.clear(),ce(new Map(x.value)),y.value.clear(),z(new Map(y.value)),D.value.clear(),Y(new Map(D.value))}};return Object.defineProperties({},{...Object.getOwnPropertyDescriptors(C),...Object.fromEntries(Object.entries(ye).map(([a,e])=>[a,{value:e,writable:!0,enumerable:!0,configurable:!0}]))})};exports.useRemoteDataSource=Se;
