/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { validatePackage as K, useImmediateInheritState as o } from "@progress/kendo-react-common";
import { process as j } from "@progress/kendo-data-query";
import { packageMetadata as L } from "../package-metadata.mjs";
const U = (t) => {
  var F, G, I, x, M, P, S;
  K(L, { component: "useDataSource" });
  const {
    defaultTotal: q,
    defaultData: w = [],
    filterable: d = !0,
    defaultFilter: y,
    sortable: f = !0,
    defaultSort: z,
    pageable: c = !0,
    defaultSkip: A,
    defaultTake: B,
    groupable: g = !0,
    defaultGroup: C,
    schema: E
  } = t, s = o((F = t.data) != null ? F : w), k = o((G = t.total) != null ? G : q, t.total), u = o((I = t.filter) != null ? I : y, t.filter), l = o((x = t.sort) != null ? x : z, t.sort), i = o((M = t.skip) != null ? M : A, t.skip), a = o((P = t.take) != null ? P : B, t.take), v = o((S = t.group) != null ? S : C, t.group), H = (e) => {
    s.value = [...e];
  }, J = (e) => {
    k.value = e;
  }, m = (e) => {
    u.value = e;
  }, D = (e) => {
    l.value = e;
  }, b = (e) => {
    i.value = e;
  }, T = (e) => {
    a.value = e;
  }, h = (e) => {
    v.value = e;
  };
  return {
    get data() {
      var e, r, n;
      return (n = j((e = t.data) != null ? e : s.value, {
        filter: d && u.value ? u.value : void 0,
        sort: f && l.value ? l.value : void 0,
        group: g && v.value ? v.value : void 0,
        ...c && a.value !== void 0 && a.value !== null ? {
          skip: (r = i.value) != null ? r : 0,
          take: a.value
        } : {}
      })) == null ? void 0 : n.data;
    },
    setData: H,
    get total() {
      var e, r, n;
      return k.value !== void 0 ? k.value : (n = j((e = t.data) != null ? e : s.value, {
        filter: d && u.value ? u.value : void 0,
        sort: f && l.value ? l.value : void 0,
        group: g && v.value ? v.value : void 0,
        ...c && a.value !== void 0 && a.value !== null ? {
          skip: (r = i.value) != null ? r : 0,
          take: a.value
        } : {}
      })) == null ? void 0 : n.total;
    },
    setTotal: J,
    get sort() {
      return l.value;
    },
    setSort: D,
    get filter() {
      return u.value;
    },
    setFilter: m,
    get skip() {
      return i.value;
    },
    setSkip: b,
    get take() {
      return a.value;
    },
    setTake: T,
    get group() {
      return v.value;
    },
    setGroup: h,
    get dataState() {
      return {
        filter: t.filter !== void 0 ? t.filter : u.value,
        sort: t.sort !== void 0 ? t.sort : l.value,
        skip: t.skip !== void 0 ? t.skip : i.value,
        take: t.take !== void 0 ? t.take : a.value,
        group: t.group !== void 0 ? t.group : v.value
      };
    },
    setDataState: (e) => {
      e.filter !== void 0 && m(e.filter), e.sort !== void 0 && D(e.sort), e.skip !== void 0 && b(e.skip), e.take !== void 0 && T(e.take), e.group !== void 0 && h(e.group);
    },
    schema: E
  };
};
export {
  U as useDataSource
};
