/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { orderBy as v, filterBy as s } from "@progress/kendo-data-query";
import { extendDataItem as y, mapTree as C, getItemPath as P, getNestedValue as g } from "@progress/kendo-react-common";
function i(t, n, r) {
  return r ? { ...t, [n]: r.length ? [...r] : void 0 } : t && t[n] ? [...t[n]] : [];
}
function B(t, n, r) {
  if (t[r]) {
    const o = i(t, r, v(i(t, r), n)), e = i(o, r).map((c) => B(c, n, r));
    return { ...o, [r]: e };
  }
  return t;
}
function E(t, n, r) {
  let o = v(t, n);
  return o = o.map((e) => B(e, n, r)), o;
}
function x(t, n, r) {
  let o = i(t, r);
  if (o && o.length) {
    o = o.map((a) => x(a, n, r));
    const l = s(o, {
      filters: [{ filters: n, logic: "and" }, { operator: (a) => !!(a[r] || []).length }],
      logic: "or"
    });
    return i(t, r, l);
  }
  return t;
}
function $(t, n, r) {
  let o = { [r]: [...t] };
  return o = x(o, n, r), o[r] || [];
}
function k(t, n, r) {
  const o = [], e = [];
  for (let c = t.length - 1; c >= 0; c--) {
    const l = t[c];
    o.push({
      root: l,
      data: n(l),
      level: [c],
      levelCount: t.length
    });
  }
  for (; o.length > 0; ) {
    const c = o.pop();
    if (e.push({
      dataItem: c.root,
      level: [...c.level],
      ...r(c.root),
      levelCount: c.levelCount
    }), c.data.length)
      for (let l = c.data.length - 1; l >= 0; l--) {
        const a = c.data[l];
        o.push({
          root: a,
          data: n(a),
          level: [...c.level, l],
          levelCount: c.data.length
        });
      }
  }
  return e;
}
const N = (t, n, r) => {
  const o = (h) => !!g(n, h), e = (h) => !!g(r, h), c = (h) => {
    const f = [];
    return o(h) && e(h) && f.push(...g(r, h)), f;
  }, l = (h, f, p) => {
    f.push({ ...h, level: p }), c(h).forEach((D) => l(D, f, p + 1));
  }, a = [];
  return t.forEach((h) => l(h, a, 0)), a;
}, V = (t, n, r, o) => {
  let e = {}, c = [], l;
  return t.forEach((a) => e[n(a)] = { ...a }), t.forEach((a) => {
    l = e[r(a)], l ? (l[o] = l[o] || [], l[o].push(e[n(a)])) : c.push(e[n(a)]);
  }), c;
}, j = (t, n, r) => y(t, n, r), q = (t, n, r) => [...C(
  [{ [n]: [...t] }],
  n,
  (e) => T(e, r, n)
)[0][n]], T = (t, n, r) => {
  const o = t[r] || [], e = o.findIndex(n);
  if (e !== -1) {
    const c = [...o];
    return c.splice(e, 1), {
      ...t,
      [r]: c
    };
  }
  return t;
}, z = (t, n, r, o) => C(
  t,
  n,
  (e) => r(e) ? { ...e, [n]: o(e[n] || []) } : e
), u = (t, n, r) => P(t, n, r), A = (t, n, r, o) => {
  const e = [...t], c = u(e, n, o), l = c.pop(), a = c.pop(), h = n[n.length - 1];
  if (r) {
    const p = u(e, r, o).pop();
    (a ? a[o] : e).splice(h, 1), p[o] = p[o] || [], p[o].push(l);
  } else
    (a ? a[o] : e).splice(h, 1), e.push(l);
  return e;
}, G = (t, n) => ({
  ...t,
  filters: t.filters.map((r) => ({ ...r, value: n }))
}), H = (t) => t != null && t.filters.length && t.filters[0].value || "", J = (t, n) => {
  if (n && !t)
    return n;
  if (t && !n)
    return t;
  if (t && n)
    return {
      logic: "and",
      filters: [t, n]
    };
};
export {
  J as combineFilters,
  V as createDataTree,
  j as extendDataItem,
  $ as filterBy,
  k as flatData,
  u as getItemPath,
  G as getSearchFromString,
  H as getStringFromSearch,
  z as modifySubItems,
  A as moveTreeItem,
  E as orderBy,
  q as removeItems,
  N as treeToFlat
};
