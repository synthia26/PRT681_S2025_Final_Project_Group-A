/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as n from "react";
const x = 50, A = 250, T = 50, m = 100, _ = ({
  viewItemsWrapperRef: c,
  isKeyboardNavigationActiveRef: f,
  processedMessages: a,
  suggestions: h
}) => {
  const u = n.useCallback(() => {
    c.current && (c.current.scrollTop = c.current.scrollHeight - c.current.clientHeight);
  }, [c]), r = n.useCallback(() => {
    if (!c.current)
      return !0;
    const t = c.current, { scrollTop: e, scrollHeight: l, clientHeight: i } = t, s = x + 25;
    return l - e - i < s;
  }, [c]), b = n.useCallback((t) => t === 0 ? 16 : t <= 2 ? 32 * t : Math.min(50 * t, 200), []), C = n.useCallback(
    (t, e) => {
      const l = b(t);
      setTimeout(() => {
        !r() && c.current && e(t + 1);
      }, l);
    },
    [b, r, c]
  ), d = n.useCallback(() => {
    const t = (e = 0) => {
      e > 5 || requestAnimationFrame(() => {
        u(), C(e, t);
      });
    };
    t();
  }, [u, C]), S = n.useCallback(() => {
    u(), setTimeout(() => {
      !r() && c.current && u();
    }, 50);
  }, [u, r, c]), L = n.useCallback(() => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        requestAnimationFrame(S);
      });
    });
  }, [S]), E = n.useCallback(() => {
    u(), setTimeout(() => {
      !r() && c.current && d();
    }, 25);
  }, [u, r, c, d]), o = n.useCallback(
    (t = !1) => {
      if (!c.current || f.current)
        return;
      r() && (t ? E() : L());
    },
    [
      r,
      E,
      L,
      c,
      f
    ]
  );
  n.useEffect(() => {
    const t = window.setTimeout(() => u(), A);
    return () => {
      clearTimeout(t);
    };
  }, [u]), n.useEffect(() => {
    d();
  }, [a.length, d]), n.useEffect(() => {
    const t = window.setTimeout(() => {
      o();
    }, T);
    return () => {
      clearTimeout(t);
    };
  }, [a, o]), n.useEffect(() => {
    if (a.length > 0) {
      const t = a[a.length - 1], e = (t == null ? void 0 : t.text) || "";
      (e.includes("```") || e.includes(`

`) || e.includes("<pre>") || e.includes("<code>") || e.includes("<table>") || e.length > 500) && o(!0);
    }
  }, [a, o]), n.useEffect(() => {
    if (h && h.length > 0) {
      const t = window.setTimeout(() => {
        o();
      }, m);
      return () => {
        clearTimeout(t);
      };
    }
  }, [h, o]), n.useEffect(() => {
    if (!c.current)
      return () => {
      };
    let t;
    const e = new ResizeObserver(() => {
      t && clearTimeout(t), t = window.setTimeout(() => {
        o();
      }, T);
    }), l = c.current.querySelector(".k-message-list-content");
    return l && e.observe(l), () => {
      e.disconnect();
    };
  }, [o, c]);
  const k = n.useCallback((t) => {
    var l;
    if (t.type !== "characterData" && t.type !== "childList")
      return !1;
    const e = (l = t.target.textContent) != null ? l : "";
    return e.includes("```") || e.includes(`

`) || e.includes("<pre>") || e.includes("<code>") || e.includes("<table>") || t.addedNodes && t.addedNodes.length > 2;
  }, []), y = n.useCallback(
    (t) => {
      let e = !1, l = !1;
      return t.forEach((i) => {
        var s;
        (i.type === "childList" || i.type === "characterData" || i.type === "attributes" && ["class", "style"].includes((s = i.attributeName) != null ? s : "")) && (e = !0, k(i) && (l = !0));
      }), { shouldScroll: e, hasSignificantChange: l };
    },
    [k]
  ), O = n.useCallback(
    (t, e) => {
      e.current && clearTimeout(e.current), t ? o(!0) : e.current = window.setTimeout(() => {
        o();
      }, T);
    },
    [o]
  );
  n.useEffect(() => {
    if (!c.current)
      return () => {
      };
    const t = { current: void 0 };
    let e = 0;
    const l = new MutationObserver((i) => {
      const s = Date.now();
      if (s - e < 16)
        return;
      e = s;
      const { shouldScroll: D, hasSignificantChange: g } = y(i);
      D && r() && O(g, t);
    });
    return l.observe(c.current, {
      childList: !0,
      subtree: !0,
      characterData: !0,
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), () => {
      l.disconnect(), t.current && clearTimeout(t.current);
    };
  }, [r, y, O, c]);
};
export {
  _ as useChatScroll
};
